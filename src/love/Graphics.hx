// DO NOT EDIT THIS FILE
// GENERATED ON 2024-05-04 09:34:57

package love;

import lua.Table;
@:native("love.graphics")
extern class Graphics {

	public static function applyTransform(transform:Transform): Void;

	@:overload
	public static function arc(drawmode:DrawMode, x:Float, y:Float, radius:Float, angle1:Float, angle2:Float, segments:Float = 10): Void;

	@:overload
	public static function arc(drawmode:DrawMode, arctype:ArcType, x:Float, y:Float, radius:Float, angle1:Float, angle2:Float, segments:Float = 10): Void;

	@:overload
	public static function captureScreenshot(filename:String): Void;

	@:overload
	public static function captureScreenshot(callback:Dynamic): Void;

	@:overload
	public static function captureScreenshot(channel:Channel): Void;

	@:overload
	public static function circle(mode:DrawMode, x:Float, y:Float, radius:Float): Void;

	@:overload
	public static function circle(mode:DrawMode, x:Float, y:Float, radius:Float, segments:Float): Void;

	@:overload
	public static function clear(): Void;

	@:overload
	public static function clear(r:Float, g:Float, b:Float, a:Float = 1, clearstencil:Bool = true, cleardepth:Bool = true): Void;

	@:overload
	public static function clear(color:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>, clearstencil:Bool = true, cleardepth:Bool = true): Void;

	@:overload
	public static function clear(clearcolor:Bool, clearstencil:Bool, cleardepth:Bool): Void;

	@:overload
	public static function discard(discardcolor:Bool = true, discardstencil:Bool = true): Void;

	@:overload
	public static function discard(discardcolors:Table<Dynamic,Dynamic>, discardstencil:Bool = true): Void;

	@:overload
	public static function draw(drawable:Drawable, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function draw(texture:Texture, quad:Quad, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function draw(drawable:Drawable, transform:Transform): Void;

	@:overload
	public static function draw(texture:Texture, quad:Quad, transform:Transform): Void;

	@:overload
	public static function drawInstanced(mesh:Mesh, instancecount:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawInstanced(mesh:Mesh, instancecount:Float, transform:Transform): Void;

	@:overload
	public static function drawLayer(texture:Texture, layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawLayer(texture:Texture, layerindex:Float, quad:Quad, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawLayer(texture:Texture, layerindex:Float, transform:Transform): Void;

	@:overload
	public static function drawLayer(texture:Texture, layerindex:Float, quad:Quad, transform:Transform): Void;

	@:overload
	public static function ellipse(mode:DrawMode, x:Float, y:Float, radiusx:Float, radiusy:Float): Void;

	@:overload
	public static function ellipse(mode:DrawMode, x:Float, y:Float, radiusx:Float, radiusy:Float, segments:Float): Void;

	public static function flushBatch(): Void;

	public static function getBackgroundColor(): BackgroundColor;

	public static function getBlendMode(): BlendMode;

	public static function getCanvas(): Canvas;

	@:overload
	public static function getCanvasFormats(): Table<Dynamic,Dynamic>;

	@:overload
	public static function getCanvasFormats(readable:Bool): Table<Dynamic,Dynamic>;

	public static function getColor(): Color;

	public static function getColorMask(): ColorMask;

	public static function getDPIScale(): Float;

	public static function getDefaultFilter(): DefaultFilter;

	public static function getDepthMode(): DepthMode;

	public static function getDimensions(): Dimensions;

	public static function getFont(): Font;

	public static function getFrontFaceWinding(): VertexWinding;

	public static function getHeight(): Float;

	public static function getImageFormats(): Table<Dynamic,Dynamic>;

	public static function getLineJoin(): LineJoin;

	public static function getLineStyle(): LineStyle;

	public static function getLineWidth(): Float;

	public static function getMeshCullMode(): CullMode;

	public static function getPixelDimensions(): PixelDimensions;

	public static function getPixelHeight(): Float;

	public static function getPixelWidth(): Float;

	public static function getPointSize(): Float;

	public static function getRendererInfo(): RendererInfo;

	public static function getScissor(): Scissor;

	public static function getShader(): Shader;

	public static function getStackDepth(): Float;

	@:overload
	public static function getStats(): Table<Dynamic,Dynamic>;

	@:overload
	public static function getStats(stats:Table<Dynamic,Dynamic>): Table<Dynamic,Dynamic>;

	public static function getStencilTest(): StencilTest;

	public static function getSupported(): Table<Dynamic,Dynamic>;

	public static function getSystemLimits(): Table<Dynamic,Dynamic>;

	public static function getTextureTypes(): Table<Dynamic,Dynamic>;

	public static function getWidth(): Float;

	public static function intersectScissor(x:Float, y:Float, width:Float, height:Float): Void;

	public static function inverseTransformPoint(screenX:Float, screenY:Float): InverseTransformPoint;

	public static function isActive(): Bool;

	public static function isGammaCorrect(): Bool;

	public static function isWireframe(): Bool;

	@:overload
	public static function line(x1:Float, y1:Float, x2:Float, y2:Float, ...:Float): Void;

	@:overload
	public static function line(points:Table<Dynamic,Dynamic>): Void;

	public static function newArrayImage(slices:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Image;

	@:overload
	public static function newCanvas(): Canvas;

	@:overload
	public static function newCanvas(width:Float, height:Float): Canvas;

	@:overload
	public static function newCanvas(width:Float, height:Float, settings:Table<Dynamic,Dynamic>): Canvas;

	@:overload
	public static function newCanvas(width:Float, height:Float, layers:Float, settings:Table<Dynamic,Dynamic>): Canvas;

	@:overload
	public static function newCubeImage(filename:String, settings:Table<Dynamic,Dynamic> = nil): Image;

	@:overload
	public static function newCubeImage(faces:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Image;

	@:overload
	public static function newFont(filename:String): Font;

	@:overload
	public static function newFont(filename:String, size:Float, hinting:HintingMode = 'normal', dpiscale:Float = love.graphics.getDPIScale()): Font;

	@:overload
	public static function newFont(filename:String, imagefilename:String): Font;

	@:overload
	public static function newFont(size:Float = 12, hinting:HintingMode = 'normal', dpiscale:Float = love.graphics.getDPIScale()): Font;

	@:overload
	public static function newImage(filename:String, settings:Table<Dynamic,Dynamic>): Image;

	@:overload
	public static function newImage(fileData:FileData, settings:Table<Dynamic,Dynamic>): Image;

	@:overload
	public static function newImage(imageData:ImageData, settings:Table<Dynamic,Dynamic>): Image;

	@:overload
	public static function newImage(compressedImageData:CompressedImageData, settings:Table<Dynamic,Dynamic>): Image;

	@:overload
	public static function newImageFont(filename:String, glyphs:String): Font;

	@:overload
	public static function newImageFont(imageData:ImageData, glyphs:String): Font;

	@:overload
	public static function newImageFont(filename:String, glyphs:String, extraspacing:Float): Font;

	@:overload
	public static function newMesh(vertices:Table<Dynamic,Dynamic>, mode:MeshDrawMode = 'fan', usage:SpriteBatchUsage = 'dynamic'): Mesh;

	@:overload
	public static function newMesh(vertexcount:Float, mode:MeshDrawMode = 'fan', usage:SpriteBatchUsage = 'dynamic'): Mesh;

	@:overload
	public static function newMesh(vertexformat:Table<Dynamic,Dynamic>, vertices:Table<Dynamic,Dynamic>, mode:MeshDrawMode = 'fan', usage:SpriteBatchUsage = 'dynamic'): Mesh;

	@:overload
	public static function newMesh(vertexformat:Table<Dynamic,Dynamic>, vertexcount:Float, mode:MeshDrawMode = 'fan', usage:SpriteBatchUsage = 'dynamic'): Mesh;

	@:overload
	public static function newMesh(vertexcount:Float, texture:Texture = nil, mode:MeshDrawMode = 'fan'): Mesh;

	@:overload
	public static function newParticleSystem(image:Image, buffer:Float = 1000): ParticleSystem;

	@:overload
	public static function newParticleSystem(texture:Texture, buffer:Float = 1000): ParticleSystem;

	@:overload
	public static function newQuad(x:Float, y:Float, width:Float, height:Float, sw:Float, sh:Float): Quad;

	@:overload
	public static function newQuad(x:Float, y:Float, width:Float, height:Float, texture:Texture): Quad;

	@:overload
	public static function newShader(code:String): Shader;

	@:overload
	public static function newShader(pixelcode:String, vertexcode:String): Shader;

	@:overload
	public static function newSpriteBatch(image:Image, maxsprites:Float = 1000): SpriteBatch;

	@:overload
	public static function newSpriteBatch(image:Image, maxsprites:Float = 1000, usage:SpriteBatchUsage = 'dynamic'): SpriteBatch;

	@:overload
	public static function newSpriteBatch(texture:Texture, maxsprites:Float = 1000, usage:SpriteBatchUsage = 'dynamic'): SpriteBatch;

	@:overload
	public static function newText(font:Font, textstring:String = nil): Text;

	@:overload
	public static function newText(font:Font, coloredtext:Table<Dynamic,Dynamic>): Text;

	@:overload
	public static function newVideo(filename:String): Video;

	@:overload
	public static function newVideo(videostream:VideoStream): Video;

	@:overload
	public static function newVideo(filename:String, settings:Table<Dynamic,Dynamic>): Video;

	@:overload
	public static function newVideo(filename:String, loadaudio:Bool = nil): Video;

	@:overload
	public static function newVideo(videostream:VideoStream, loadaudio:Bool = nil): Video;

	public static function newVolumeImage(layers:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Image;

	public static function origin(): Void;

	@:overload
	public static function points(x:Float, y:Float, ...:Float): Void;

	@:overload
	public static function points(points:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function points(points:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function polygon(mode:DrawMode, ...:Float): Void;

	@:overload
	public static function polygon(mode:DrawMode, vertices:Table<Dynamic,Dynamic>): Void;

	public static function pop(): Void;

	public static function present(): Void;

	@:overload
	public static function print(text:String, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function print(text:String, transform:Transform): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, transform:Transform): Void;

	@:overload
	public static function print(text:String, font:Font, transform:Transform): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, font:Font, transform:Transform): Void;

	@:overload
	public static function printf(text:String, x:Float, y:Float, limit:Float, align:AlignMode = 'left', r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(text:String, font:Font, x:Float, y:Float, limit:Float, align:AlignMode = 'left', r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(text:String, transform:Transform, limit:Float, align:AlignMode = 'left'): Void;

	@:overload
	public static function printf(text:String, font:Font, transform:Transform, limit:Float, align:AlignMode = 'left'): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, x:Float, y:Float, limit:Float, align:AlignMode, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, font:Font, x:Float, y:Float, limit:Float, align:AlignMode = 'left', angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, transform:Transform, limit:Float, align:AlignMode = 'left'): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, font:Font, transform:Transform, limit:Float, align:AlignMode = 'left'): Void;

	@:overload
	public static function push(): Void;

	@:overload
	public static function push(stack:StackType): Void;

	@:overload
	public static function rectangle(mode:DrawMode, x:Float, y:Float, width:Float, height:Float): Void;

	@:overload
	public static function rectangle(mode:DrawMode, x:Float, y:Float, width:Float, height:Float, rx:Float, ry:Float = rx, segments:Float = nil): Void;

	public static function replaceTransform(transform:Transform): Void;

	public static function reset(): Void;

	public static function rotate(angle:Float): Void;

	public static function scale(sx:Float, sy:Float = sx): Void;

	@:overload
	public static function setBackgroundColor(red:Float, green:Float, blue:Float, alpha:Float = 1): Void;

	@:overload
	public static function setBackgroundColor(rgba:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setBlendMode(mode:BlendMode): Void;

	@:overload
	public static function setBlendMode(mode:BlendMode, alphamode:BlendAlphaMode = 'alphamultiply'): Void;

	@:overload
	public static function setCanvas(canvas:Canvas, mipmap:Float = 1): Void;

	@:overload
	public static function setCanvas(): Void;

	@:overload
	public static function setCanvas(canvas1:Canvas, canvas2:Canvas, ...:Canvas): Void;

	@:overload
	public static function setCanvas(canvas:Canvas, slice:Float, mipmap:Float = 1): Void;

	@:overload
	public static function setCanvas(setup:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setColor(red:Float, green:Float, blue:Float, alpha:Float = 1): Void;

	@:overload
	public static function setColor(rgba:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setColorMask(red:Bool, green:Bool, blue:Bool, alpha:Bool): Void;

	@:overload
	public static function setColorMask(): Void;

	public static function setDefaultFilter(min:FilterMode, mag:FilterMode = min, anisotropy:Float = 1): Void;

	@:overload
	public static function setDepthMode(comparemode:CompareMode, write:Bool): Void;

	@:overload
	public static function setDepthMode(): Void;

	public static function setFont(font:Font): Void;

	public static function setFrontFaceWinding(winding:VertexWinding): Void;

	public static function setLineJoin(join:LineJoin): Void;

	public static function setLineStyle(style:LineStyle): Void;

	public static function setLineWidth(width:Float): Void;

	public static function setMeshCullMode(mode:CullMode): Void;

	@:overload
	public static function setNewFont(size:Float = 12): Font;

	@:overload
	public static function setNewFont(filename:String, size:Float = 12): Font;

	@:overload
	public static function setNewFont(file:File, size:Float = 12): Font;

	@:overload
	public static function setNewFont(data:Data, size:Float = 12): Font;

	@:overload
	public static function setNewFont(rasterizer:Rasterizer): Font;

	public static function setPointSize(size:Float): Void;

	@:overload
	public static function setScissor(x:Float, y:Float, width:Float, height:Float): Void;

	@:overload
	public static function setScissor(): Void;

	@:overload
	public static function setShader(shader:Shader): Void;

	@:overload
	public static function setShader(): Void;

	@:overload
	public static function setStencilTest(comparemode:CompareMode, comparevalue:Float): Void;

	@:overload
	public static function setStencilTest(): Void;

	public static function setWireframe(enable:Bool): Void;

	public static function shear(kx:Float, ky:Float): Void;

	public static function stencil(stencilfunction:Dynamic, action:StencilAction = 'replace', value:Float = 1, keepvalues:Bool = false): Void;

	public static function transformPoint(globalX:Float, globalY:Float): TransformPoint;

	public static function translate(dx:Float, dy:Float): Void;

	@:overload
	public static function validateShader(gles:Bool, code:String): ValidateShader;

	@:overload
	public static function validateShader(gles:Bool, pixelcode:String, vertexcode:String): ValidateShader;

}

extern class BackgroundColor {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern class BlendMode {
	public var mode:BlendMode;
	public var alphamode:BlendAlphaMode;
}

extern class Color {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern class ColorMask {
	public var r:Bool;
	public var g:Bool;
	public var b:Bool;
	public var a:Bool;
}

extern class DefaultFilter {
	public var min:FilterMode;
	public var mag:FilterMode;
	public var anisotropy:Float;
}

extern class DepthMode {
	public var comparemode:CompareMode;
	public var write:Bool;
}

extern class Dimensions {
	public var width:Float;
	public var height:Float;
}

extern class PixelDimensions {
	public var pixelwidth:Float;
	public var pixelheight:Float;
}

extern class RendererInfo {
	public var name:String;
	public var version:String;
	public var vendor:String;
	public var device:String;
}

extern class Scissor {
	public var x:Float;
	public var y:Float;
	public var width:Float;
	public var height:Float;
}

extern class StencilTest {
	public var comparemode:CompareMode;
	public var comparevalue:Float;
}

extern class InverseTransformPoint {
	public var globalX:Float;
	public var globalY:Float;
}

extern class TransformPoint {
	public var screenX:Float;
	public var screenY:Float;
}

extern class ValidateShader {
	public var status:Bool;
	public var message:String;
}

extern class ValidateShader {
	public var status:Bool;
	public var message:String;
}

extern class Canvas extends Texture {

	public static function generateMipmaps(): Void;

	public static function getMSAA(): Float;

	public static function getMipmapMode(): MipmapMode;

	@:overload
	public static function newImageData(): ImageData;

	@:overload
	public static function newImageData(slice:Float, mipmap:Float = 1, x:Float, y:Float, width:Float, height:Float): ImageData;

	public static function renderTo(func:Dynamic): Void;

}

extern class Drawable extends Object {

}

extern class Font extends Object {

	public static function getAscent(): Float;

	public static function getBaseline(): Float;

	public static function getDPIScale(): Float;

	public static function getDescent(): Float;

	public static function getFilter(): Filter;

	public static function getHeight(): Float;

	@:overload
	public static function getKerning(leftchar:String, rightchar:String): Float;

	@:overload
	public static function getKerning(leftglyph:Float, rightglyph:Float): Float;

	public static function getLineHeight(): Float;

	public static function getWidth(text:String): Float;

	public static function getWrap(text:String, wraplimit:Float): Wrap;

	@:overload
	public static function hasGlyphs(text:String): Bool;

	@:overload
	public static function hasGlyphs(character1:String, character2:String): Bool;

	@:overload
	public static function hasGlyphs(codepoint1:Float, codepoint2:Float): Bool;

	public static function setFallbacks(fallbackfont1:Font, ...:Font): Void;

	public static function setFilter(min:FilterMode, mag:FilterMode, anisotropy:Float = 1): Void;

	public static function setLineHeight(height:Float): Void;

}

extern class Image extends Texture {

	public static function getFlags(): Table<Dynamic,Dynamic>;

	public static function isCompressed(): Bool;

	public static function replacePixels(data:ImageData, slice:Float, mipmap:Float = 1, x:Float = 0, y:Float = 0, reloadmipmaps:Bool): Void;

}

extern class Mesh extends Drawable {

	@:overload
	public static function attachAttribute(name:String, mesh:Mesh): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Mesh, step:VertexAttributeStep = 'pervertex', attachname:String = name): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Mesh): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Mesh, step:VertexAttributeStep = 'pervertex', attachname:String = name): Void;

	public static function detachAttribute(name:String): Bool;

	public static function getDrawMode(): MeshDrawMode;

	public static function getDrawRange(): DrawRange;

	public static function getTexture(): Texture;

	@:overload
	public static function getVertex(index:Float): Vertex;

	@:overload
	public static function getVertex(index:Float): Vertex;

	public static function getVertexAttribute(vertexindex:Float, attributeindex:Float): VertexAttribute;

	public static function getVertexCount(): Float;

	public static function getVertexFormat(): Table<Dynamic,Dynamic>;

	public static function getVertexMap(): Table<Dynamic,Dynamic>;

	public static function isAttributeEnabled(name:String): Bool;

	public static function setAttributeEnabled(name:String, enable:Bool): Void;

	public static function setDrawMode(mode:MeshDrawMode): Void;

	@:overload
	public static function setDrawRange(start:Float, count:Float): Void;

	@:overload
	public static function setDrawRange(): Void;

	@:overload
	public static function setTexture(texture:Texture): Void;

	@:overload
	public static function setTexture(): Void;

	@:overload
	public static function setVertex(index:Float, attributecomponent:Float, ...:Float): Void;

	@:overload
	public static function setVertex(index:Float, vertex:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setVertex(index:Float, x:Float, y:Float, u:Float, v:Float, r:Float = 1, g:Float = 1, b:Float = 1, a:Float = 1): Void;

	@:overload
	public static function setVertex(index:Float, vertex:Table<Dynamic,Dynamic>): Void;

	public static function setVertexAttribute(vertexindex:Float, attributeindex:Float, value1:Float, value2:Float, ...:Float): Void;

	@:overload
	public static function setVertexMap(map:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setVertexMap(vi1:Float, vi2:Float, vi3:Float): Void;

	@:overload
	public static function setVertexMap(data:Data, datatype:IndexDataType): Void;

	@:overload
	public static function setVertices(vertices:Table<Dynamic,Dynamic>, startvertex:Float = 1, count:Float = all): Void;

	@:overload
	public static function setVertices(data:Data, startvertex:Float = 1): Void;

	@:overload
	public static function setVertices(vertices:Table<Dynamic,Dynamic>): Void;

}

extern class ParticleSystem extends Drawable {

	public static function clone(): ParticleSystem;

	public static function emit(numparticles:Float): Void;

	public static function getBufferSize(): Float;

	public static function getColors(): Colors;

	public static function getCount(): Float;

	public static function getDirection(): Float;

	public static function getEmissionArea(): EmissionArea;

	public static function getEmissionRate(): Float;

	public static function getEmitterLifetime(): Float;

	public static function getInsertMode(): ParticleInsertMode;

	public static function getLinearAcceleration(): LinearAcceleration;

	public static function getLinearDamping(): LinearDamping;

	public static function getOffset(): Offset;

	public static function getParticleLifetime(): ParticleLifetime;

	public static function getPosition(): Position;

	public static function getQuads(): Table<Dynamic,Dynamic>;

	public static function getRadialAcceleration(): RadialAcceleration;

	public static function getRotation(): Rotation;

	public static function getSizeVariation(): Float;

	public static function getSizes(): Sizes;

	public static function getSpeed(): Speed;

	public static function getSpin(): Spin;

	public static function getSpinVariation(): Float;

	public static function getSpread(): Float;

	public static function getTangentialAcceleration(): TangentialAcceleration;

	public static function getTexture(): Texture;

	public static function hasRelativeRotation(): Bool;

	public static function isActive(): Bool;

	public static function isPaused(): Bool;

	public static function isStopped(): Bool;

	public static function moveTo(x:Float, y:Float): Void;

	public static function pause(): Void;

	public static function reset(): Void;

	public static function setBufferSize(size:Float): Void;

	@:overload
	public static function setColors(r1:Float, g1:Float, b1:Float, a1:Float = 1, r2:Float = nil, g2:Float = nil, b2:Float = nil, a2:Float = 1, r8:Float = nil, g8:Float = nil, b8:Float = nil, a8:Float = 1): Void;

	@:overload
	public static function setColors(rgba1:Table<Dynamic,Dynamic>, rgba2:Table<Dynamic,Dynamic> = nil, rgba8:Table<Dynamic,Dynamic> = nil): Void;

	public static function setDirection(direction:Float): Void;

	public static function setEmissionArea(distribution:AreaSpreadDistribution, dx:Float, dy:Float, angle:Float = 0, directionRelativeToCenter:Bool = false): Void;

	public static function setEmissionRate(rate:Float): Void;

	public static function setEmitterLifetime(life:Float): Void;

	public static function setInsertMode(mode:ParticleInsertMode): Void;

	public static function setLinearAcceleration(xmin:Float, ymin:Float, xmax:Float = xmin, ymax:Float = ymin): Void;

	public static function setLinearDamping(min:Float, max:Float = min): Void;

	public static function setOffset(x:Float, y:Float): Void;

	public static function setParticleLifetime(min:Float, max:Float = min): Void;

	public static function setPosition(x:Float, y:Float): Void;

	@:overload
	public static function setQuads(quad1:Quad, quad2:Quad): Void;

	@:overload
	public static function setQuads(quads:Table<Dynamic,Dynamic>): Void;

	public static function setRadialAcceleration(min:Float, max:Float = min): Void;

	public static function setRelativeRotation(enable:Bool): Void;

	public static function setRotation(min:Float, max:Float = min): Void;

	public static function setSizeVariation(variation:Float): Void;

	public static function setSizes(size1:Float, size2:Float = nil, size8:Float = nil): Void;

	public static function setSpeed(min:Float, max:Float = min): Void;

	public static function setSpin(min:Float, max:Float = min): Void;

	public static function setSpinVariation(variation:Float): Void;

	public static function setSpread(spread:Float): Void;

	public static function setTangentialAcceleration(min:Float, max:Float = min): Void;

	public static function setTexture(texture:Texture): Void;

	public static function start(): Void;

	public static function stop(): Void;

	public static function update(dt:Float): Void;

}

extern class Quad extends Object {

	public static function getTextureDimensions(): TextureDimensions;

	public static function getViewport(): Viewport;

	public static function setViewport(x:Float, y:Float, w:Float, h:Float, sw:Float, sh:Float): Void;

}

extern class Shader extends Object {

	public static function getWarnings(): String;

	public static function hasUniform(name:String): Bool;

	@:overload
	public static function send(name:String, number:Float, ...:Float): Void;

	@:overload
	public static function send(name:String, vector:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, matrix:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, texture:Texture): Void;

	@:overload
	public static function send(name:String, boolean:Bool, ...:Bool): Void;

	@:overload
	public static function send(name:String, matrixlayout:MatrixLayout, matrix:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, data:Data, offset:Float = 0, size:Float = all): Void;

	@:overload
	public static function send(name:String, data:Data, matrixlayout:MatrixLayout, offset:Float = 0, size:Float = all): Void;

	@:overload
	public static function send(name:String, matrixlayout:MatrixLayout, data:Data, offset:Float = 0, size:Float = all): Void;

	public static function sendColor(name:String, color:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

}

extern class SpriteBatch extends Drawable {

	@:overload
	public static function add(x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function add(quad:Quad, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, quad:Quad, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, transform:Transform): Float;

	@:overload
	public static function addLayer(layerindex:Float, quad:Quad, transform:Transform): Float;

	public static function attachAttribute(name:String, mesh:Mesh): Void;

	public static function clear(): Void;

	public static function flush(): Void;

	public static function getBufferSize(): Float;

	public static function getColor(): Color;

	public static function getCount(): Float;

	public static function getTexture(): Texture;

	@:overload
	public static function set(spriteindex:Float, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function set(spriteindex:Float, quad:Quad, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setColor(r:Float, g:Float, b:Float, a:Float = 1): Void;

	@:overload
	public static function setColor(): Void;

	@:overload
	public static function setDrawRange(start:Float, count:Float): Void;

	@:overload
	public static function setDrawRange(): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, quad:Quad, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, transform:Transform): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, quad:Quad, transform:Transform): Void;

	public static function setTexture(texture:Texture): Void;

}

extern class Text extends Drawable {

	@:overload
	public static function add(textstring:String, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function add(coloredtext:Table<Dynamic,Dynamic>, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addf(textstring:String, wraplimit:Float, align:AlignMode, x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addf(coloredtext:Table<Dynamic,Dynamic>, wraplimit:Float, align:AlignMode, x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	public static function clear(): Void;

	@:overload
	public static function getDimensions(): Dimensions;

	@:overload
	public static function getDimensions(index:Float): Dimensions;

	public static function getFont(): Font;

	@:overload
	public static function getHeight(): Float;

	@:overload
	public static function getHeight(index:Float): Float;

	@:overload
	public static function getWidth(): Float;

	@:overload
	public static function getWidth(index:Float): Float;

	@:overload
	public static function set(textstring:String): Void;

	@:overload
	public static function set(coloredtext:Table<Dynamic,Dynamic>): Void;

	public static function setFont(font:Font): Void;

	@:overload
	public static function setf(textstring:String, wraplimit:Float, align:AlignMode): Void;

	@:overload
	public static function setf(coloredtext:Table<Dynamic,Dynamic>, wraplimit:Float, align:AlignMode): Void;

}

extern class Texture extends Drawable {

	public static function getDPIScale(): Float;

	public static function getDepth(): Float;

	public static function getDepthSampleMode(): CompareMode;

	public static function getDimensions(): Dimensions;

	public static function getFilter(): Filter;

	public static function getFormat(): PixelFormat;

	public static function getHeight(): Float;

	public static function getLayerCount(): Float;

	public static function getMipmapCount(): Float;

	public static function getMipmapFilter(): MipmapFilter;

	public static function getPixelDimensions(): PixelDimensions;

	public static function getPixelHeight(): Float;

	public static function getPixelWidth(): Float;

	public static function getTextureType(): TextureType;

	public static function getWidth(): Float;

	public static function getWrap(): Wrap;

	public static function isReadable(): Bool;

	public static function setDepthSampleMode(compare:CompareMode): Void;

	public static function setFilter(min:FilterMode, mag:FilterMode = min, anisotropy:Float = 1): Void;

	@:overload
	public static function setMipmapFilter(filtermode:FilterMode, sharpness:Float = 0): Void;

	@:overload
	public static function setMipmapFilter(): Void;

	public static function setWrap(horiz:WrapMode, vert:WrapMode = horiz, depth:WrapMode = horiz): Void;

}

extern class Video extends Drawable {

	public static function getDimensions(): Dimensions;

	public static function getFilter(): Filter;

	public static function getHeight(): Float;

	public static function getSource(): Source;

	public static function getStream(): VideoStream;

	public static function getWidth(): Float;

	public static function isPlaying(): Bool;

	public static function pause(): Void;

	public static function play(): Void;

	public static function rewind(): Void;

	public static function seek(offset:Float): Void;

	public static function setFilter(min:FilterMode, mag:FilterMode, anisotropy:Float = 1): Void;

	public static function setSource(source:Source = nil): Void;

	public static function tell(): Float;

}

enum AlignMode {
	Center;
	Left;
	Right;
	Justify;
}

enum ArcType {
	Pie;
	Open;
	Closed;
}

enum AreaSpreadDistribution {
	Uniform;
	Normal;
	Ellipse;
	Borderellipse;
	Borderrectangle;
	None;
}

enum BlendAlphaMode {
	Alphamultiply;
	Premultiplied;
}

enum BlendMode {
	Alpha;
	Replace;
	Screen;
	Add;
	Subtract;
	Multiply;
	Lighten;
	Darken;
	Additive;
	Subtractive;
	Multiplicative;
	Premultiplied;
}

enum CompareMode {
	Equal;
	Notequal;
	Less;
	Lequal;
	Gequal;
	Greater;
	Never;
	Always;
}

enum CullMode {
	Back;
	Front;
	None;
}

enum DrawMode {
	Fill;
	Line;
}

enum FilterMode {
	Linear;
	Nearest;
}

enum GraphicsFeature {
	Clampzero;
	Lighten;
	Multicanvasformats;
	Glsl3;
	Instancing;
	Fullnpot;
	Pixelshaderhighp;
	Shaderderivatives;
}

enum GraphicsLimit {
	Pointsize;
	Texturesize;
	Multicanvas;
	Canvasmsaa;
	Texturelayers;
	Volumetexturesize;
	Cubetexturesize;
	Anisotropy;
}

enum IndexDataType {
	Uint16;
	Uint32;
}

enum LineJoin {
	Miter;
	None;
	Bevel;
}

enum LineStyle {
	Rough;
	Smooth;
}

enum MeshDrawMode {
	Fan;
	Strip;
	Triangles;
	Points;
}

enum MipmapMode {
	None;
	Auto;
	Manual;
}

enum ParticleInsertMode {
	Top;
	Bottom;
	Random;
}

enum SpriteBatchUsage {
	Dynamic;
	Static;
	Stream;
}

enum StackType {
	Transform;
	All;
}

enum StencilAction {
	Replace;
	Increment;
	Decrement;
	Incrementwrap;
	Decrementwrap;
	Invert;
}

enum TextureType {
	2d;
	Array;
	Cube;
	Volume;
}

enum VertexAttributeStep {
	Pervertex;
	Perinstance;
}

enum VertexWinding {
	Cw;
	Ccw;
}

enum WrapMode {
	Clamp;
	Repeat;
	Mirroredrepeat;
	Clampzero;
}

