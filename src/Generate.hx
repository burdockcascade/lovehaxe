package;

import haxe.Http;
import haxe.Json;
import sys.io.File;
import sys.io.FileOutput;

class Generate {

    private static var LOVE_API_URL = "https://love2d-community.github.io/love-api/love-api.json";

    public static function main() {
        var http = new haxe.Http(LOVE_API_URL);

        http.onData = function(data:String) {
            try {
                new Generator(haxe.Json.parse(data));
            } catch (error:Dynamic) {
                trace('Error parsing JSON data: $error');
            }
        };

        http.onError = function(error:String) {
            trace('Error downloading JSON: $error');
        };

        http.request();
    }
}

class Generator {

    var structTracker = new Map<String, Bool>();
    var love2dVersion:String;

    // iterate over modules
    public function new(apiData:Dynamic) : Void {
        love2dVersion = apiData.version;
        trace('Generating bindings for LOVE version ${love2dVersion}');
        for (i in 0...apiData.modules.length) {
            writeModule(apiData.modules[i]);
        }
    }

    private function writeModule(module:Dynamic) : Void {

        var mod_name = module.name;
        var mod_functions = module.functions;
        var mod_types = module.types;
        var mod_constants = module.enums;

        // clear tracker
        structTracker = new Map<String, Bool>();

        trace("Generating bindings for module " + mod_name);

        // capitalise first letter
        var class_name = capitalizeFirstLetter(mod_name);

        // create file
        var fout = File.write('lib/love/${class_name}.hx');

        // gerneration date
        var gen_date = Date.now();

        // add warning to file header
        fout.writeString('/*\n * This file was generated by the LOVE2D Haxe bindings generator for Love2D v${love2dVersion}.\n * Do not modify this file directly.\n * ${gen_date}\n */\n\n');

        // add package declaration
        fout.writeString("package love;\n\n");

        // add native name
        fout.writeString('@:native("love.${mod_name}")\n');

        // write class
        writeClass(fout, class_name, mod_functions);

        // write types
        if (mod_types != null) {
            writeTypes(fout, mod_types);
        }

        // write enums
        if (mod_constants != null) {
            writeEnums(fout, mod_constants);
        }

        // write return structs
        writeFunctionReturnStructs(fout, module);

    }

    private function writeTypes(fout:FileOutput, types:Array<Dynamic>) : Void {

        for (i in 0...types.length) {
            var hxType = types[i];

            var className = capitalizeFirstLetter(hxType.name);

            // add type declaration
            fout.writeString('extern class ${className} {\n\n');

            // write functions
            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    writeFunction(fout, hxType.functions[i]);
                }
            }

            // end type
            fout.writeString("}\n\n");

        }

    }

    private function writeClass(fout:FileOutput, class_name:String, functions:Array<Dynamic>) : Void {

        // add class declaration
        fout.writeString('extern class ${class_name} {\n\n');

        // write function
        for (i in 0...functions.length) {
            writeFunction(fout, functions[i]);
        }

        // end class
        fout.writeString("}\n\n");

    }

    private function writeFunctionReturnStructs(fout:FileOutput, module:Dynamic) : Void {

        // write return structs for types
        for (i in 0...module.types.length) {
            var hxType = module.types[i];
            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    var func = hxType.functions[i];
                    writeFunctionReturnStruct(fout, func);
                }
            }

        }

        // write return structs for module
        for (i in 0...module.functions.length) {
            var func = module.functions[i];
            writeFunctionReturnStruct(fout, func);
        }

    }

    private function writeFunctionReturnStruct(fout:FileOutput, func:Dynamic) : Void {
            
        var variants = func.variants;
        var funcName = func.name;

        for (i in 0...variants.length) {

            var variant = variants[i];

            if (variant.returns != null && variant.returns.length > 1) {

                var className = getFunctionStructName(funcName);

                if (structTracker[className] != null) {
                    return;
                }

                structTracker[className] = true;

                // add return type
                fout.writeString('extern class ${className} {\n\n');

                for (i in 0...variant.returns.length) {
                    var variantReturn = variant.returns[i];
                    var returnName = variantReturn.name;
                    var returnType = mapType(variantReturn.type);
                    fout.writeString('\tpublic var ${returnName}:${returnType};\n');
                }

                fout.writeString('\n}\n\n');

            }

        }

    }

    private function getFunctionStructName(funcName:String) : String {

        // remove get from function name
        if (funcName.indexOf('get') == 0) {
            funcName = funcName.substr(3);
        } else {
            funcName = funcName  + 'Result';
        }

        // capitalise first letter
        funcName = capitalizeFirstLetter(funcName);

        return funcName;
    }

    private function writeFunction(fout:FileOutput, func:Dynamic) : Void {
        
        var identation = '\t';

        var variants: Array<Dynamic> = func.variants;
        var functionName: String = func.name;

        for (i in 0...variants.length) {

            var variant: Dynamic  = variants[i];
            var variantReturns: Array<Dynamic> = variant.returns;
            var variantArgs: Array<Dynamic> = variant.arguments;

            // if multiple variants then add overload annotation
            if (variants.length > 1) {
                fout.writeString('${identation}@:overload\n');
            }

            // add function declaration
            fout.writeString('${identation}public static function ${functionName}(');

            // if args then write them
            if (variantArgs != null) {
                for (i in 0...variantArgs.length) {
                    var arg: Dynamic = variantArgs[i];
                    var argName: String = arg.name;
                    var argType: String = mapType(arg.type);
        
                    // add argument
                    fout.writeString('${argName}:${argType}');
        
                    // add comma if not last argument
                    if (i < variantArgs.length - 1) {
                        fout.writeString(', ');
                    }
                }
            }

            // add default return type
            var returnType: String = "Void";

            // if return type exists
            if (variantReturns != null) {

                if (variantReturns.length == 1) {
                    returnType = mapType(variantReturns[0].type);
                } else if (variantReturns.length > 1) {
                    returnType = getFunctionStructName(functionName);
                }

            }

            // add return type
            fout.writeString('):${returnType};\n\n');

        }
    }

    // write enums
    private function writeEnums(fout:FileOutput, enums:Array<Dynamic>) : Void {

        for (i in 0...enums.length) {
            var hxEnum: Dynamic = enums[i];

            // add enum declaration
            fout.writeString('extern enum ${hxEnum.name} {\n');

            // write values
            for (i in 0...hxEnum.constants.length) {
                var value: Dynamic = hxEnum.constants[i];

                // set to uppercase
                var valueName: String = value.name.toUpperCase();

                // add value
                fout.writeString('\t${valueName};\n');
            }

            // end enum
            fout.writeString("}\n\n");

        }

    }

    private static function mapType(type:String) : String {
        switch (type) {
            case "boolean":
                return "Bool";
            case "number":
                return "Float";
            case "string":
                return "String";
            case "table":
                return "Table<Dynamic,Dynamic>";
            case "nil":
                return "Null";
            default:
                return capitalizeFirstLetter(type);
        }
    }

    private static function capitalizeFirstLetter(str:String) : String {
        return str.charAt(0).toUpperCase() + str.substr(1);
    }

}