package;

import haxe.Http;
import haxe.Json;
import haxe.crypto.Md5;
import sys.io.File;

// todo
// 1) fix keyboad enums

class Generate {

    private static var LOVE_API_URL = "https://love2d-community.github.io/love-api/love-api.json";
    private static var LOVE_API_MD5 = "target/love-api.md5";
    private static var LOVE_API_JSON = "target/love-api.json";

    private static var GEN_OVERIDE:Bool = true;

    public static function main() {
        var http = new Http(LOVE_API_URL);

        http.onData = function(data:String) {

            // hash downloaded json
            var data_md5 = Md5.encode(data);

            // if override is disabled
            if (!GEN_OVERIDE) {
                // read local md5
                var fin = File.getContent(LOVE_API_MD5);

                // if md5 is the same then skip
                if (fin == data_md5) {
                    trace('No changes in LOVE API. Skipping generation.');
                    return;
                }
            }

            var fout_md5 = File.write(LOVE_API_MD5);
            fout_md5.writeString(data_md5);

            // write json to file
            var fout = File.write(LOVE_API_JSON);
            fout.writeString(data);

            try {
                new Generator(Json.parse(data));
            } catch (error:Dynamic) {
                trace('Error parsing JSON data: $error');
            }
        };

        http.onError = function(error:String) {
            trace('Error downloading JSON: $error');
        };

        http.request();
    }
}

class Generator {

    var importSources = new Map<String, String>();
    var love2dVersion:String;

    // iterate over modules
    public function new(apiData:Dynamic) : Void {
        love2dVersion = apiData.version;
        trace('Generating bindings for LOVE version ${love2dVersion}');

        // compile modules
        var modules = compileModules(apiData);

        // write modules
        write(modules);

    }

    private function write(modules:Array<HxModule>) : Void {

        for (module in modules) {

            // create file
            var fout = File.write('lib/love2d/${module.name}.hx');

            // add warning to file header
            fout.writeString('/*\n * This file was generated by the LOVE2D Haxe bindings generator for Love2D v${love2dVersion}.\n');
            fout.writeString(' * Do not modify this file directly.\n');
            fout.writeString(' * ${Date.now()}\n');
            fout.writeString(' */\n\n');

            // package
            fout.writeString('package ${module.pkg};\n\n');

            // imports
            for (i in 0...module.imports.length) {
                fout.writeString('import ${module.imports[i]};\n');
            }

            // write dependencies
            for (i in 0...module.dependencies.length) {

                var dependency = module.dependencies[i];
                var importSource = importSources.get(dependency);

                // exclude self 
                if (importSource == module.name) {
                    continue;
                }

                if (importSource != null) {
                    fout.writeString('import love2d.${importSource}.${dependency};\n');
                }
            
            }

            fout.writeString('\n');

            // write classes
            for (hxClass in module.classes) {

                // write annotations
                for (annotation in hxClass.annotations) {
                    fout.writeString('@${annotation}\n');
                }

                // write class
                fout.writeString('extern class ${hxClass.name} ');

                // write parent class
                if (hxClass.parent != null) {
                    fout.writeString('extends ${hxClass.parent} ');
                }

                fout.writeString('{\n\n');

                // write fields
                for (field in hxClass.fields) {
                    var isStatic = field.isStatic ? 'static ' : '';
                    fout.writeString('\tpublic ${isStatic}var ${field.name}:${field.type};\n');
                }

                fout.writeString('\n');

                for (func in hxClass.functions) {

                    // each variant
                    for (i in 0...func.variants.length) {

                        var variant = func.variants[i];

                        // check if last variant
                        var is_overloaded_function = func.variants.length > 1 && i < func.variants.length - 1;

                        // if last variant then add annotation
                        if (is_overloaded_function) {
                            fout.writeString('\t@:overload(function (');
                        } else if (func.is_static) {
                            fout.writeString('\tpublic static function ${func.name}(');
                        } else {
                            fout.writeString('\tfunction ${func.name}(');
                        }

                        for (i in 0...variant.args.length) {

                            // write arg
                            var arg: HxField = variant.args[i];

                            // if vararg then add varname
                            if (arg.name == "...") {
                                arg.name = '...varargs';
                            }

                            fout.writeString('${arg.name}:${arg.type}');
    
                            // add default value if presetnt
                            if (arg.defaultValue != null) {
                                // fixme: default values can not be mapped
                                // fout.writeString(' = ${arg.defaultValue}');
                            }
    
                            // add comma if not last arg
                            if (i < variant.args.length - 1) {
                                fout.writeString(', ');
                            }
                        }
                        
                        fout.writeString('):${variant.returnType}');

                        if (is_overloaded_function) {
                            fout.writeString(' {})\n');
                        } else {
                            fout.writeString(';\n');
                        }
        
                    }

                    fout.writeString('\n');


                }
                fout.writeString('}\n\n');
            }

            // write enums
            for (hxEnum in module.enums) {
                fout.writeString('extern enum ${hxEnum.name} {\n');
                for (value in hxEnum.values) {
                    fout.writeString('\t${value};\n');
                }
                fout.writeString('}\n\n');
            }
        
        }

    }

    public function compileModules(apiData:Dynamic) : Array<HxModule> {

        var modules = new Array<HxModule>();

        // root functions
        // types or empty array
        if (apiData.types == null) {
            apiData.types = new Array<Dynamic>();
        }

        // enums or empty array
        if (apiData.enums == null) {
            apiData.enums = new Array<Dynamic>();
        }

        // compile root module
        var rootModule = compileModule('love', 'love', apiData.functions, apiData.types, apiData.enums);
        var hxClass = rootModule.classes.get('Love');

        // compile callbacks as root variables
        for (i in 0...apiData.callbacks.length) {
            var callback = apiData.callbacks[i];
            var hxField = new HxField(callback.name, 'Void->Void', true);
            hxClass.fields.set(callback.name, hxField);
        }

        rootModule.classes.set('Love', hxClass);
        modules.push(rootModule);

        // modules
        for (i in 0...apiData.modules.length) {
            var module = apiData.modules[i];

            // types or empty array
            if (module.types == null) {
                module.types = new Array<Dynamic>();
            }

            // enums or empty array
            if (module.enums == null) {
                module.enums = new Array<Dynamic>();
            }

            var compiled_mod = compileModule(module.name, 'love.${module.name}', module.functions, module.types, module.enums);

            modules.push(compiled_mod);

        }

        // process dependencies for each module
        for (module in modules) {

            var deps = new Map<String, Dynamic>();

            for (hxClass in module.classes) {

                if (hxClass.parent != null) {
                    if (module.classes.get(hxClass.parent) == null && importSources.get(hxClass.parent) != null) {
                        deps.set(hxClass.parent, null);
                    }
                }

                for (func in hxClass.functions) {
                    for (variant in func.variants) {
                        for (arg in variant.args) {
                            if (module.classes.get(arg.type) == null && importSources.get(arg.type) != null) {
                                deps.set(arg.type, null);
                            }
                        }
                    }
                }
            }

            // add deps
            for (dep in deps.keys()) {
                module.dependencies.push(dep);
            }

        }

        return modules;
    }

    private function compileModule(module_name: String, nativeName: String, functions: Array<Dynamic>, types: Array<Dynamic>, enums: Array<Dynamic>) : HxModule {

        trace('Compiling module ${module_name}');

        var capitalized_module_name = capitalizeFirstLetter(module_name);

        // if filesytem then use CamelCase
        if (module_name == 'filesystem') {
            capitalized_module_name = 'FileSystem';
        }

        var hxModule = new HxModule(capitalized_module_name);
        hxModule.pkg = 'love2d';
        hxModule.imports.push('lua.Table');
        hxModule.imports.push('lua.UserData');
        hxModule.native_name = nativeName;

        // convert love types to haxe classes
        for (i in 0...types.length) {

            var hxType = types[i];
            var hxClass = new HxClass(capitalizeFirstLetter(hxType.name));

            // insert empty constructor
            var hxVariant = new HxVariant();
            hxVariant.returnType = 'Void';
            var hxFunction = new HxFunction('new');
            hxFunction.variants.push(hxVariant);
            hxClass.functions.set("new", hxFunction);
            
            if (hxType.supertypes != null) {
                hxClass.parent = capitalizeFirstLetter(hxType.supertypes[0]);
            }

            // write functions
            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    var compiledFunction = compileFunction(hxClass.name, hxType.functions[i]);
                    hxClass.functions.set(compiledFunction.func.name, compiledFunction.func);
                    for (i in 0...compiledFunction.returnClasses.length) {
                        hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
                    }
                }
            }

            hxModule.classes.set(hxClass.name, hxClass);

        }

        // convert love enums to haxe enums
        for (i in 0...enums.length) {
            var hxEnum = new HxEnum(enums[i].name);
            if (enums[i].constants != null) {
                for (j in 0...enums[i].constants.length) {
                    hxEnum.values.push(enums[i].constants[j].name.toUpperCase());
                }
                hxModule.enums.set(hxEnum.name, hxEnum);
            }
        }

        // remember where enums are kept
        for (hxEnumName in hxModule.enums.keys()) {
            importSources.set(hxEnumName, hxModule.name);
        }
        
        // convert love module to haxe class
        var prefix = module_name == 'love' ? '' : 'Love';
        var hxClass = new HxClass(prefix + capitalized_module_name);

        // set love namespace
        hxClass.annotations.push(':native("${hxModule.native_name}")');

        // write functions
        for (i in 0...functions.length) {
            var compiledFunction = compileFunction(capitalized_module_name, functions[i], true);
            hxClass.functions.set(compiledFunction.func.name, compiledFunction.func);
            for (i in 0...compiledFunction.returnClasses.length) {
                hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
            }
        }
        hxModule.classes.set(hxClass.name, hxClass);

        // remember where classes are kept
        for (hxClassName in hxModule.classes.keys()) {
            importSources.set(hxClassName, hxModule.name);
        }

        return hxModule;

    }

    private function compileFunction(class_name, func:Dynamic, is_static: Bool = false) : CompiledFunction {

        var hxFunction = new HxFunction(func.name);
        hxFunction.is_static = is_static;
        var variants: Array<Dynamic> = func.variants;
       
        var returnClasses = new Array<HxClass>();

        // write variants
        for (i in 0...variants.length) {

            var hxVariant = new HxVariant();

            var variant: Dynamic = variants[i];
            var variantReturns: Array<Dynamic> = variant.returns;
            var variantArgs: Array<Dynamic> = variant.arguments;

            // if args then write them
            if (variantArgs != null) {
                for (i in 0...variantArgs.length) {
                    
                    var arg = new HxField(variantArgs[i].name, mapType(variantArgs[i].type));

                    // if default value exists
                    var defaultValue = Reflect.field(variantArgs[i], "default");

                    if (defaultValue != null) {
                        arg.defaultValue = mapType(defaultValue);
                    }

                    hxVariant.args.push(arg);
                }
            }

            // add default return type
            hxVariant.returnType = 'Void';

            // if return type exists
            if (variantReturns != null) {

                if (variantReturns.length == 1) {
                    hxVariant.returnType = mapType(variantReturns[0].type);
                } else if (variantReturns.length > 1) {
                    
                    var struct_name = getFunctionStructName(class_name, func.name);

                    // set return type to the struct name
                    hxVariant.returnType = struct_name;

                    // flag if return type has varargs
                    var isDynamicSize = false;
                    
                    // create a struct for the return type
                    var hxClass = new HxClass(struct_name);
                    hxClass.annotations.push(':multiReturn');

                    // loop each value
                    for (i in 0...variantReturns.length) {
                        var variantReturn = variantReturns[i];
                        var field = new HxField(variantReturn.name, mapType(variantReturn.type));

                        // check for duplicates (this only happens to FileSytem.Read)
                        if (hxClass.fields.exists(field.name)) {
                            field = new HxField(variantReturn.name, "Dynamic");
                        }

                        // if field is Dynamic then set flag
                        if (variantReturn.name == "...") {
                            isDynamicSize = true;
                            break;
                        }

                        hxClass.fields.set(field.name, field);
                    }

                    if (isDynamicSize) {
                        hxVariant.returnType = 'Array<Dynamic>';
                    } else {
                        returnClasses.push(hxClass);
                    }

                }

            }

            hxFunction.variants.push(hxVariant);
            
        }

        return {
            func: hxFunction,
            returnClasses: returnClasses
        };

    }

    private function getFunctionStructName(class_name, funcName:String) : String {

        // remove get from function name
        if (funcName.indexOf('get') == 0) {
            funcName = funcName.substr(3);
        } else {
            funcName = funcName  + 'Result';
        }

        // capitalise first letter
        funcName = capitalizeFirstLetter(funcName);

        return class_name + funcName;
    }

    

    private static function mapType(type:String) : String {

        // if ends with "or string" then return string
        if (type.indexOf('or') != -1) {
            return 'Dynamic';
        }

        switch (type) {
            case "boolean":
                return "Bool";
            case "number":
                return "Float";
            case "string":
                return "String";
            case "table":
                return "Table<Dynamic,Dynamic>";
            case "nil":
                return "Null";
            case "Variant":
                return "Dynamic";
            case "any":
                return "Dynamic";
            case "function":    
                return "Dynamic";
            case "cdata":
                return "Dynamic";
            case "light userdata":
                return "UserData";
            default:
                return capitalizeFirstLetter(type);
        }
    }

    private static function capitalizeFirstLetter(str:String) : String {
        return str.charAt(0).toUpperCase() + str.substr(1);
    }

}

class HxModule {
    public var name: String;
    public var native_name: String;
    public var pkg: String;
    public var imports: Array<String>;
    public var classes: Map<String, HxClass>;
    public var enums: Map<String, HxEnum>;
    public var dependencies: Array<String>;

    public function new(name: String) {
        this.name = name;
        imports = new Array<String>();
        classes = new Map<String, HxClass>();
        enums = new Map<String, HxEnum>();
        dependencies = new Array<String>();
    }
}

class HxClass {
    public var name: String;
    public var parent: String;
    public var fields: Map<String, HxField>;
    public var functions: Map<String, HxFunction>;
    public var annotations: Array<String>;

    public function new(name: String) {
        this.name = name;
        fields = new Map<String, HxField>();
        functions = new Map<String, HxFunction>();
        annotations = new Array<String>();
    }
}

class HxEnum {
    public var name: String;
    public var values: Array<String>;

    public function new(name: String) {
        this.name = name;
        values = new Array<String>();
    }
}

class HxField {
    public var name: String;
    public var type: String;
    public var defaultValue: String;
    public var isStatic: Bool;

    public function new(name: String, type: String, isStatic: Bool = false) {
        this.name = name;
        this.type = type;
        this.isStatic = isStatic;
    }
}

class HxFunction {
    public var name: String;
    public var variants: Array<HxVariant>;
    public var is_static: Bool;

    public function new(name: String) {
        this.name = name;
        is_static = false;
        variants = new Array<HxVariant>();
    }
}

class HxVariant {
    public var args: Array<HxField>;
    public var returnType: String;

    public function new() {
        args = new Array<HxField>();
    }
}

typedef CompiledFunction = {
    func: HxFunction,
    returnClasses: Array<HxClass>
};