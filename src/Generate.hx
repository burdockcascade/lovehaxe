package;

import haxe.Http;
import haxe.Json;
import sys.io.File;
import sys.io.FileOutput;

// todo
// 1) fix keyboad enums
// 2) fix vararg returns

class Generate {

    private static var LOVE_API_URL = "https://love2d-community.github.io/love-api/love-api.json";

    public static function main() {
        var http = new haxe.Http(LOVE_API_URL);

        http.onData = function(data:String) {
            try {

                // write json to file
                var fout = File.write('target/love-api.json');
                fout.writeString(data);

                new Generator(haxe.Json.parse(data));
            } catch (error:Dynamic) {
                trace('Error parsing JSON data: $error');
            }
        };

        http.onError = function(error:String) {
            trace('Error downloading JSON: $error');
        };

        http.request();
    }
}

class Generator {

    var importSources = new Map<String, String>();
    var love2dVersion:String;

    // iterate over modules
    public function new(apiData:Dynamic) : Void {
        love2dVersion = apiData.version;
        trace('Generating bindings for LOVE version ${love2dVersion}');

        // compile modules
        var modules = compileModules(apiData);

        // write modules
        write(modules);

    }

    private function write(modules:Array<HxModule>) : Void {

        for (module in modules) {

            // create file
            var fout = File.write('lib/love/${module.name}.hx');

            // add warning to file header
            fout.writeString('/*\n * This file was generated by the LOVE2D Haxe bindings generator for Love2D v${love2dVersion}.\n');
            fout.writeString(' * Do not modify this file directly.\n');
            fout.writeString(' * ${Date.now()}\n');
            fout.writeString(' */\n\n');

            // package
            fout.writeString('package ${module.pkg};\n\n');

            // imports
            for (i in 0...module.imports.length) {
                fout.writeString('import ${module.imports[i]};\n');
            }

            // write dependencies
            for (i in 0...module.dependencies.length) {

                var dependency = module.dependencies[i];
                var importSource = importSources.get(dependency);

                if (importSource != null) {
                    fout.writeString('import love.${importSource}.${dependency};\n');
                }
            
            }

            fout.writeString('\n');

            // write classes
            for (hxClass in module.classes) {

                // write annotations
                for (annotation in hxClass.annotations) {
                    fout.writeString('@${annotation}\n');
                }

                // write class
                fout.writeString('extern class ${hxClass.name} ');

                // write parent class
                if (hxClass.parent != null) {
                    fout.writeString('extends ${hxClass.parent} ');
                }

                fout.writeString('{\n\n');

                // write fields
                for (field in hxClass.fields) {
                    if (field.name == "...") {
                        trace('Skipping field ${field.name} of type ${field.type} in class ${hxClass.name} in module ${module.name}.');
                        fout.writeString('\t// Skipping field ${field.name} of type ${field.type}.\n');
                        continue;
                    } else {
                        fout.writeString('\tpublic var ${field.name}:${field.type};\n');
                    }
                }

                for (func in hxClass.functions) {

                    // each variant
                    for (i in 0...func.variants.length) {

                        var variant = func.variants[i];

                        // check if last variant
                        var is_overloaded_function = func.variants.length > 1 && i < func.variants.length - 1;

                        // if last variant then add annotation
                        if (is_overloaded_function) {
                            fout.writeString('\t@:overload(function (');
                        } else if (func.is_static) {
                            fout.writeString('\tpublic static function ${func.name}(');
                        } else {
                            fout.writeString('\tfunction ${func.name}(');
                        }

                        for (i in 0...variant.args.length) {

                            // write arg
                            var arg: HxField = variant.args[i];

                            // if vararg then add varname
                            if (arg.name == "...") {
                                arg.name = '...varargs';
                            }

                            fout.writeString('${arg.name}:${arg.type}');
    
                            // add default value if presetnt
                            if (arg.defaultValue != null) {
                                // fixme: default values can not be mapped
                                // fout.writeString(' = ${arg.defaultValue}');
                            }
    
                            // add comma if not last arg
                            if (i < variant.args.length - 1) {
                                fout.writeString(', ');
                            }
                        }
                        
                        fout.writeString('):${variant.returnType}');

                        if (is_overloaded_function) {
                            fout.writeString(' {})\n');
                        } else {
                            fout.writeString(';\n');
                        }
        
                    }

                    fout.writeString('\n');


                }
                fout.writeString('}\n\n');
            }

            // write enums
            for (hxEnum in module.enums) {
                fout.writeString('extern enum ${hxEnum.name} {\n');
                for (value in hxEnum.values) {
                    fout.writeString('\t${value};\n');
                }
                fout.writeString('}\n\n');
            }
        
        }

    }

    public function compileModules(apiData:Dynamic) : Array<HxModule> {

        var modules = new Array<HxModule>();

        // root functions
        // types or empty array
        if (apiData.types == null) {
            apiData.types = new Array<Dynamic>();
        }

        // enums or empty array
        if (apiData.enums == null) {
            apiData.enums = new Array<Dynamic>();
        }

        // compile root module
        modules.push(compileModule('Love2D', apiData.functions, apiData.types, apiData.enums));

        // modules
        for (i in 0...apiData.modules.length) {
            var module = apiData.modules[i];

            // types or empty array
            if (module.types == null) {
                module.types = new Array<Dynamic>();
            }

            // enums or empty array
            if (module.enums == null) {
                module.enums = new Array<Dynamic>();
            }

            modules.push(compileModule(module.name, module.functions, module.types, module.enums));
        }

        // process dependencies for each module
        for (module in modules) {

            var deps = new Map<String, Dynamic>();

            for (hxClass in module.classes) {

                if (hxClass.parent != null) {
                    if (module.classes.get(hxClass.parent) == null && importSources.get(hxClass.parent) != null) {
                        deps.set(hxClass.parent, null);
                    }
                }

                for (func in hxClass.functions) {
                    for (variant in func.variants) {
                        for (arg in variant.args) {
                            if (module.classes.get(arg.type) == null && importSources.get(arg.type) != null) {
                                deps.set(arg.type, null);
                            }
                        }
                    }
                }
            }

            // print deps
            for (dep in deps.keys()) {
                module.dependencies.push(dep);
            }

        }

        return modules;
    }

    private function compileModule(modName: String, functions: Array<Dynamic>, types: Array<Dynamic>, enums: Array<Dynamic>) : HxModule {

        var hxModule = new HxModule(capitalizeFirstLetter(modName));

        trace('Compiling module ${hxModule.name}');

        hxModule.pkg = 'love';
        hxModule.imports.push('lua.Table');
        hxModule.imports.push('lua.UserData');
        hxModule.nativeName = 'love.${modName}';

        // convert love types to haxe classes
        for (i in 0...types.length) {

            var hxType = types[i];
            var hxClass = new HxClass(capitalizeFirstLetter(hxType.name));
            
            if (hxType.supertypes != null) {
                hxClass.parent = capitalizeFirstLetter(hxType.supertypes[0]);
            }

            // write functions
            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    var compiledFunction = compileFunction(hxType.functions[i]);
                    hxClass.functions.push(compiledFunction.func);
                    for (i in 0...compiledFunction.returnClasses.length) {
                        hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
                    }
                }
            }

            hxModule.classes.set(hxClass.name, hxClass);

        }

        // convert love enums to haxe enums
        for (i in 0...enums.length) {
            var hxEnum = new HxEnum(enums[i].name);
            if (enums[i].constants != null) {
                for (j in 0...enums[i].constants.length) {
                    hxEnum.values.push(enums[i].constants[j].name.toUpperCase());
                }
                hxModule.enums.set(hxEnum.name, hxEnum);
            }
        }
        
        // convert love module to haxe class
        var hxClass = new HxClass(capitalizeFirstLetter(modName) + "Module");
        for (i in 0...functions.length) {
            var compiledFunction = compileFunction(functions[i], true);
            hxClass.functions.push(compiledFunction.func);
            for (i in 0...compiledFunction.returnClasses.length) {
                hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
            }
        }
        hxModule.classes.set(hxClass.name, hxClass);

        // remember where classes are kept
        for (hxClassName in hxModule.classes.keys()) {
            importSources.set(hxClassName, hxModule.name);
        }

        return hxModule;

    }

    private function compileFunction(func:Dynamic, is_static: Bool = false) : CompiledFunction {

        var hxFunction = new HxFunction(func.name);
        hxFunction.is_static = is_static;
        var variants: Array<Dynamic> = func.variants;
       
        var returnClasses = new Array<HxClass>();

        // write variants
        for (i in 0...variants.length) {

            var hxVariant = new HxVariant();

            var variant: Dynamic  = variants[i];
            var variantReturns: Array<Dynamic> = variant.returns;
            var variantArgs: Array<Dynamic> = variant.arguments;

            // if args then write them
            if (variantArgs != null) {
                for (i in 0...variantArgs.length) {
                    
                    var arg = new HxField(variantArgs[i].name, mapType(variantArgs[i].type));

                    // if default value exists
                    var defaultValue = Reflect.field(variantArgs[i], "default");

                    if (defaultValue != null) {
                        arg.defaultValue = mapType(defaultValue);
                    }

                    hxVariant.args.push(arg);
                }
            }

            // add default return type
            hxVariant.returnType = 'Void';

            // if return type exists
            if (variantReturns != null) {

                if (variantReturns.length == 1) {
                    hxVariant.returnType = mapType(variantReturns[0].type);
                } else if (variantReturns.length > 1) {
                    
                    // set return type to the struct name
                    hxVariant.returnType = getFunctionStructName(func.name);
                    
                    // create a struct for the return type
                    var hxClass = new HxClass(getFunctionStructName(func.name));
                    hxClass.annotations.push(':multiReturn');

                    for (i in 0...variant.returns.length) {
                        var variantReturn = variant.returns[i];
                        hxClass.fields.push(new HxField(variantReturn.name, mapType(variantReturn.type)));
                    }
                    returnClasses.push(hxClass);

                }

            }

            hxFunction.variants.push(hxVariant);
            
        }

        return {
            func: hxFunction,
            returnClasses: returnClasses
        };

    }

    private function getFunctionStructName(funcName:String) : String {

        // remove get from function name
        if (funcName.indexOf('get') == 0) {
            funcName = funcName.substr(3);
        } else {
            funcName = funcName  + 'Result';
        }

        // capitalise first letter
        funcName = capitalizeFirstLetter(funcName);

        return funcName;
    }

    

    private static function mapType(type:String) : String {

        // if ends with "or string" then return string
        if (type.indexOf(' or string') != -1) {
            return 'String';
        }

        switch (type) {
            case "boolean":
                return "Bool";
            case "number":
                return "Float";
            case "string":
                return "String";
            case "table":
                return "Table<Dynamic,Dynamic>";
            case "nil":
                return "Null";
            case "Variant":
                return "Dynamic";
            case "any":
                return "Dynamic";
            case "function":    
                return "Dynamic";
            case "cdata":
                return "Dynamic";
            case "light userdata":
                return "UserData";
            default:
                return capitalizeFirstLetter(type);
        }
    }

    private static function capitalizeFirstLetter(str:String) : String {
        return str.charAt(0).toUpperCase() + str.substr(1);
    }

}

class HxModule {
    public var name: String;
    public var nativeName: String;
    public var pkg: String;
    public var imports: Array<String>;
    public var classes: Map<String, HxClass>;
    public var enums: Map<String, HxEnum>;
    public var dependencies: Array<String>;

    public function new(name: String) {
        this.name = name;
        imports = new Array<String>();
        classes = new Map<String, HxClass>();
        enums = new Map<String, HxEnum>();
        dependencies = new Array<String>();
    }
}

class HxClass {
    public var name: String;
    public var parent: String;
    public var fields: Array<HxField>;
    public var functions: Array<HxFunction>;
    public var annotations: Array<String>;

    public function new(name: String) {
        this.name = name;
        fields = new Array<HxField>();
        functions = new Array<HxFunction>();
        annotations = new Array<String>();
    }
}

class HxEnum {
    public var name: String;
    public var values: Array<String>;

    public function new(name: String) {
        this.name = name;
        values = new Array<String>();
    }
}

class HxField {
    public var name: String;
    public var type: String;
    public var defaultValue: String;

    public function new(name: String, type: String) {
        this.name = name;
        this.type = type;
    }
}

class HxFunction {
    public var name: String;
    public var variants: Array<HxVariant>;
    public var is_static: Bool;

    public function new(name: String) {
        this.name = name;
        is_static = false;
        variants = new Array<HxVariant>();
    }
}

class HxVariant {
    public var args: Array<HxField>;
    public var returnType: String;

    public function new() {
        args = new Array<HxField>();
    }
}

typedef CompiledFunction = {
    func: HxFunction,
    returnClasses: Array<HxClass>
};