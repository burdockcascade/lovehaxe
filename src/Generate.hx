package;

import haxe.Http;
import haxe.Json;
import sys.io.File;
import sys.io.FileOutput;

class Generate {

    private static var LOVE_API_URL = "https://love2d-community.github.io/love-api/love-api.json";

    public static function main() {
        var http = new haxe.Http(LOVE_API_URL);

        http.onData = function(data:String) {
            try {
                new Generator(haxe.Json.parse(data));
            } catch (error:Dynamic) {
                trace('Error parsing JSON data: $error');
            }
        };

        http.onError = function(error:String) {
            trace('Error downloading JSON: $error');
        };

        http.request();
    }
}

class Generator {

    var importSources = new Map<String, String>();
    var love2dVersion:String;

    // iterate over modules
    public function new(apiData:Dynamic) : Void {
        love2dVersion = apiData.version;
        trace('Generating bindings for LOVE version ${love2dVersion}');

        // compile modules
        var modules = compileModules(apiData);

        // write modules
        write(modules);

    }

    private function write(modules:Array<HxModule>) : Void {

        for (module in modules) {

            // create file
            var fout = File.write('lib/love/${module.name}.hx');

            // add warning to file header
            fout.writeString('/*\n * This file was generated by the LOVE2D Haxe bindings generator for Love2D v${love2dVersion}.\n');
            fout.writeString(' * Do not modify this file directly.\n');
            fout.writeString(' * ${Date.now()}\n');
            fout.writeString(' */\n\n');

            // package
            fout.writeString('package ${module.pkg};\n\n');

            // imports
            for (i in 0...module.imports.length) {
                fout.writeString('import ${module.imports[i]};\n');
            }

            // write dependencies
            for (i in 0...module.dependencies.length) {

                var dependency = module.dependencies[i];
                var importSource = importSources.get(dependency);

                if (importSource != null) {
                    fout.writeString('import love.${importSource}.${dependency};\n');
                }
            
            }

            fout.writeString('\n');

            // write classes
            for (hxClass in module.classes) {

                // write class
                fout.writeString('extern class ${hxClass.name} ');
                if (hxClass.parent != null) {
                    fout.writeString('extends ${hxClass.parent} {\n');
                } else {
                    fout.writeString('{\n');
                }

                // write fields
                for (field in hxClass.fields) {
                    fout.writeString('\tpublic var ${field.name}:${field.type};\n');
                }

                for (func in hxClass.functions) {
                    fout.writeString('\tpublic static function ${func.name}(');
                    for (i in 0...func.variants[0].args.length) {

                        // write arg
                        var arg: HxField = func.variants[0].args[i];
                        fout.writeString('${arg.name}:${arg.type}');

                        // add default value if presetnt
                        if (arg.defaultValue != null) {
                            fout.writeString(' = ${arg.defaultValue}');
                        }

                        // add comma if not last arg
                        if (i < func.variants[0].args.length - 1) {
                            fout.writeString(', ');
                        }
                    }
                    fout.writeString('):${func.variants[0].returnType};\n');
                }
                fout.writeString('}\n\n');
            }

            // write enums
            for (hxEnum in module.enums) {
                fout.writeString('extern enum ${hxEnum.name} {\n');
                for (value in hxEnum.values) {
                    fout.writeString('\t${value};\n');
                }
                fout.writeString('}\n\n');
            }
        
        }

    }

    public function compileModules(apiData:Dynamic) : Array<HxModule> {

        var modules = new Array<HxModule>();

        // root functions
        // types or empty array
        if (apiData.types == null) {
            apiData.types = new Array<Dynamic>();
        }

        // enums or empty array
        if (apiData.enums == null) {
            apiData.enums = new Array<Dynamic>();
        }

        modules.push(compileModule('Love2D', apiData.functions, apiData.types, apiData.enums));

        // modules
        for (i in 0...apiData.modules.length) {
            var module = apiData.modules[i];

            // types or empty array
            if (module.types == null) {
                module.types = new Array<Dynamic>();
            }

            // enums or empty array
            if (module.enums == null) {
                module.enums = new Array<Dynamic>();
            }

            modules.push(compileModule(module.name, module.functions, module.types, module.enums));
        }

        // process dependencies for each module
        for (module in modules) {

            var deps = new Map<String, Dynamic>();

            for (hxClass in module.classes) {

                if (hxClass.parent != null) {
                    if (module.classes.get(hxClass.parent) == null && importSources.get(hxClass.parent) != null) {
                        deps.set(hxClass.parent, null);
                    }
                }

                for (func in hxClass.functions) {
                    for (variant in func.variants) {
                        for (arg in variant.args) {
                            if (module.classes.get(arg.type) == null && importSources.get(arg.type) != null) {
                                deps.set(arg.type, null);
                            }
                        }
                    }
                }
            }

            // print deps
            for (dep in deps.keys()) {
                module.dependencies.push(dep);
            }

        }

        return modules;
    }

    private function compileModule(modName: String, functions: Array<Dynamic>, types: Array<Dynamic>, enums: Array<Dynamic>) : HxModule {

        var hxModule = new HxModule(capitalizeFirstLetter(modName));

        trace('Compiling module ${hxModule.name}');

        hxModule.pkg = 'love';
        hxModule.imports.push('lua.Table');
        hxModule.nativeName = 'love.${modName}';

        // write class
        var hxClass = new HxClass(capitalizeFirstLetter(modName));
        for (i in 0...functions.length) {
            var compiledFunction = compileFunction(functions[i]);
            hxClass.functions.push(compiledFunction.func);
            for (i in 0...compiledFunction.returnClasses.length) {
                hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
            }
        }
        hxModule.classes.set(hxClass.name, hxClass);

        // write types
        if (types != null) {

            for (i in 0...types.length) {

                var hxType = types[i];
                var hxClass = new HxClass(capitalizeFirstLetter(hxType.name));
                
                if (hxType.supertypes != null) {
                    hxClass.parent = capitalizeFirstLetter(hxType.supertypes[0]);
                }
    
                // write functions
                if (hxType.functions != null) {
                    for (i in 0...hxType.functions.length) {
                        var compiledFunction = compileFunction(hxType.functions[i]);
                        hxClass.functions.push(compiledFunction.func);
                        for (i in 0...compiledFunction.returnClasses.length) {
                            hxModule.classes.set(compiledFunction.returnClasses[i].name, compiledFunction.returnClasses[i]);
                        }
                    }
                }
    
                hxModule.classes.set(hxClass.name, hxClass);
    
            }
        }

        // write enums
        if (enums != null) {
            for (i in 0...enums.length) {
                var hxEnum = new HxEnum(enums[i].name);
                if (enums[i].constants != null) {
                    for (j in 0...enums[i].constants.length) {
                        hxEnum.values.push(enums[i].constants[j].name.toUpperCase());
                    }
                    hxModule.enums.set(hxEnum.name, hxEnum);
                }
            }
        }

        // remember where classes are kept
        for (hxClassName in hxModule.classes.keys()) {
            importSources.set(hxClassName, hxModule.name);
        }

        return hxModule;

    }

    private function compileFunction(func:Dynamic) : CompiledFunction {

        var hxFunction = new HxFunction(func.name);
        var variants: Array<Dynamic> = func.variants;
       
        var returnClasses = new Array<HxClass>();

        // write variants
        for (i in 0...variants.length) {

            var hxVariant = new HxVariant();

            var variant: Dynamic  = variants[i];
            var variantReturns: Array<Dynamic> = variant.returns;
            var variantArgs: Array<Dynamic> = variant.arguments;

            // if args then write them
            if (variantArgs != null) {
                for (i in 0...variantArgs.length) {
                    
                    var arg = new HxField(variantArgs[i].name, mapType(variantArgs[i].type));

                    // if default value exists
                    var defaultValue = Reflect.field(variantArgs[i], "default");

                    if (defaultValue != null) {
                        arg.defaultValue = mapType(defaultValue);
                    }

                    hxVariant.args.push(arg);
                }
            }

            // add default return type
            hxVariant.returnType = 'Void';

            // if return type exists
            if (variantReturns != null) {

                if (variantReturns.length == 1) {
                    hxVariant.returnType = mapType(variantReturns[0].type);
                } else if (variantReturns.length > 1) {
                    
                    // set return type to the struct name
                    hxVariant.returnType = getFunctionStructName(func.name);
                    
                    // create a struct for the return type
                    var hxClass = new HxClass(getFunctionStructName(func.name));
                    for (i in 0...variant.returns.length) {
                        var variantReturn = variant.returns[i];
                        hxClass.fields.push(new HxField(variantReturn.name, mapType(variantReturn.type)));
                    }
                    returnClasses.push(hxClass);

                }

            }

            hxFunction.variants.push(hxVariant);
            
        }

        return {
            func: hxFunction,
            returnClasses: returnClasses
        };

    }

    private function getFunctionStructName(funcName:String) : String {

        // remove get from function name
        if (funcName.indexOf('get') == 0) {
            funcName = funcName.substr(3);
        } else {
            funcName = funcName  + 'Result';
        }

        // capitalise first letter
        funcName = capitalizeFirstLetter(funcName);

        return funcName;
    }

    

    private static function mapType(type:String) : String {
        switch (type) {
            case "boolean":
                return "Bool";
            case "number":
                return "Float";
            case "string":
                return "String";
            case "table":
                return "Table<Dynamic,Dynamic>";
            case "nil":
                return "Null";
            default:
                return capitalizeFirstLetter(type);
        }
    }

    private static function capitalizeFirstLetter(str:String) : String {
        return str.charAt(0).toUpperCase() + str.substr(1);
    }

}

class HxModule {
    public var name: String;
    public var nativeName: String;
    public var pkg: String;
    public var imports: Array<String>;
    public var classes: Map<String, HxClass>;
    public var enums: Map<String, HxEnum>;
    public var dependencies: Array<String>;

    public function new(name: String) {
        this.name = name;
        imports = new Array<String>();
        classes = new Map<String, HxClass>();
        enums = new Map<String, HxEnum>();
        dependencies = new Array<String>();
    }
}

class HxClass {
    public var name: String;
    public var parent: String;
    public var fields: Array<HxField>;
    public var functions: Array<HxFunction>;

    public function new(name: String) {
        this.name = name;
        fields = new Array<HxField>();
        functions = new Array<HxFunction>();
    }
}

class HxEnum {
    public var name: String;
    public var values: Array<String>;

    public function new(name: String) {
        this.name = name;
        values = new Array<String>();
    }
}

class HxField {
    public var name: String;
    public var type: String;
    public var defaultValue: String;

    public function new(name: String, type: String) {
        this.name = name;
        this.type = type;
    }
}

class HxFunction {
    public var name: String;
    public var variants: Array<HxVariant>;

    public function new(name: String) {
        this.name = name;
        variants = new Array<HxVariant>();
    }
}

class HxVariant {
    public var args: Array<HxField>;
    public var returnType: String;

    public function new() {
        args = new Array<HxField>();
    }
}

typedef CompiledFunction = {
    func: HxFunction,
    returnClasses: Array<HxClass>
};