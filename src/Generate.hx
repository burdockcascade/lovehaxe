package;

import haxe.Http;
import haxe.Json;
import sys.io.File;
import sys.io.FileOutput;

class Generate {

    private static var LOVE_API_URL = "https://love2d-community.github.io/love-api/love-api.json";

    public static function main() {
        var http = new haxe.Http(LOVE_API_URL);

        http.onData = function(data:String) {
            try {
                new Generate(haxe.Json.parse(data));
            } catch (error:Dynamic) {
                trace('Error parsing JSON data: $error');
            }
        };

        http.onError = function(error:String) {
            trace('Error downloading JSON: $error');
        };

        http.request();
    }

    // iterate over modules
    public function new(apiData:Dynamic) : Void {
        trace("Generating bindings for LOVE version " + apiData.version);
        for (i in 0...apiData.modules.length) {
            writeModule(apiData.modules[i]);
        }
    }

    private function writeModule(module:Dynamic) : Void {

        var mod_name = module.name;
        var mod_functions = module.functions;
        var mod_types = module.types;
        var mod_constants = module.enums;

        trace("Generating bindings for module " + mod_name);

        // capitalise first letter
        var class_name = capitalizeFirstLetter(mod_name);

        // create file
        var fout = File.write('lib/love/${class_name}.hx');

        // gerneration date
        var gen_date = Date.now();

        // add warning to file header
        fout.writeString('/*\n * This file was generated by the LOVE2D Haxe bindings generator.\n * Do not modify this file directly.\n * ${gen_date}\n */\n\n');

        // add package declaration
        fout.writeString("package love;\n\n");

        // add native name
        fout.writeString('@:native("love.${mod_name}")\n');

        // write class
        writeClass(fout, class_name, mod_functions);

        // write types
        if (mod_types != null) {
            writeTypes(fout, mod_types);
        }

        // write enums
        if (mod_constants != null) {
            writeEnums(fout, mod_constants);
        }

        // write return structs
        writeFunctionReturnStructs(fout, module);

    }

    private function writeTypes(fout:FileOutput, types:Array<Dynamic>) : Void {

        for (i in 0...types.length) {
            var hxType = types[i];

            var className = capitalizeFirstLetter(hxType.name);

            // add type declaration
            fout.writeString('extern class ${className} {\n\n');

            // write functions
            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    writeFunction(fout, hxType.functions[i]);
                }
            }

            // end type
            fout.writeString("}\n\n");

        }

    }

    private function writeClass(fout:FileOutput, class_name:String, functions:Array<Dynamic>) : Void {

        // add class declaration
        fout.writeString('extern class ${class_name} {\n\n');

        // write function
        for (i in 0...functions.length) {
            writeFunction(fout, functions[i]);
        }

        // end class
        fout.writeString("}\n\n");

    }

    private function writeFunctionReturnStructs(fout:FileOutput, module:Dynamic) : Void {

        // keep track of structs already written
        var structTracker = new Map<String, Bool>();

        // write return structs for module
        for (i in 0...module.functions.length) {
            var func = module.functions[i];
            if (structTracker[func.name] == null) {
                structTracker[func.name] = true;
                writeFunctionReturnStruct(fout, func);
            }
        }

        // write return structs for types
        for (i in 0...module.types.length) {

            var hxType = module.types[i];

            if (hxType.functions != null) {
                for (i in 0...hxType.functions.length) {
                    var func = hxType.functions[i];
                    if (structTracker[func.name] == null) {
                        structTracker[func.name] = true;
                        writeFunctionReturnStruct(fout, func);
                    }
                }
            }

        }

    }

    private function writeFunctionReturnStruct(fout:FileOutput, func:Dynamic) : Void {
            
        var variants = func.variants;
        var funcName = func.name;

        for (i in 0...variants.length) {

            var variant = variants[i];

            if (variant.returns != null && variant.returns.length > 1) {

                var className = getFunctionStructName(funcName);

                // add return type
                fout.writeString('extern class ${className} {\n\n');

                for (i in 0...variant.returns.length) {
                    var variantReturn = variant.returns[i];
                    var returnName = variantReturn.name;
                    var returnType = mapType(variantReturn.type);
                    fout.writeString('\tpublic var ${returnName}:${returnType};\n');
                }

                fout.writeString('\n}\n\n');

            }

        }

    }

    private function getFunctionStructName(funcName:String) : String {

        // remove get from function name
        if (funcName.indexOf('get') == 0) {
            funcName = funcName.substr(3);
        } else {
            funcName = funcName  + 'Result';
        }

        // capitalise first letter
        funcName = capitalizeFirstLetter(funcName);

        return '${funcName}';
    }

    private function writeFunction(fout:FileOutput, func:Dynamic) : Void {
        
        var variants = func.variants;
        var functionName = func.name;

        for (i in 0...variants.length) {

            var variant = variants[i];
            var variantReturns = variant.returns;
            var variantArgs = variant.arguments;

            // add function declaration
            fout.writeString('\tpublic static function ${functionName}(');

            // if args then write them
            if (variantArgs != null) {
                for (i in 0...variantArgs.length) {
                    var arg = variantArgs[i];
                    var argName = arg.name;
                    var argType = mapType(arg.type);
        
                    // add argument
                    fout.writeString('${argName}:${argType}');
        
                    // add comma if not last argument
                    if (i < variantArgs.length - 1) {
                        fout.writeString(', ');
                    }
                }
            }

            // add default return type
            var returnType = "Void";

            // if return type exists
            if (variantReturns != null) {

                if (variantReturns.length == 1) {
                    returnType = mapType(variantReturns[0].type);
                } else if (variantReturns.length > 1) {
                    returnType = getFunctionStructName(functionName);
                }

            }

            // add return type
            fout.writeString('):${returnType};\n\n');

        }
    }

    // write enums
    private function writeEnums(fout:FileOutput, enums:Array<Dynamic>) : Void {

        for (i in 0...enums.length) {
            var hxEnum = enums[i];

            // add enum declaration
            fout.writeString('extern enum ${hxEnum.name} {\n');

            // write values
            for (i in 0...hxEnum.constants.length) {
                var value = hxEnum.constants[i];

                // set to uppercase
                var valueName = value.name.toUpperCase();

                // add value
                fout.writeString('\t${valueName};\n');
            }

            // end enum
            fout.writeString("}\n\n");

        }

    }

    private static function mapType(type:String) : String {
        switch (type) {
            case "boolean":
                return "Bool";
            case "number":
                return "Float";
            case "string":
                return "String";
            case "table":
                return "Dynamic";
            default:
                return capitalizeFirstLetter(type);
        }
    }

    private static function capitalizeFirstLetter(str:String) : String {
        return str.charAt(0).toUpperCase() + str.substr(1);
    }

}