// DO NOT EDIT THIS FILE
// GENERATED ON 2024-05-04 00:35:19

package love.graphics;

import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

@:native("love.graphics")
extern class Graphics {

	public static function applyTransform(transform:Dynamic): Void;

	@:overload
	public static function arc(drawmode:Dynamic, x:Float, y:Float, radius:Float, angle1:Float, angle2:Float, segments:Float = 10): Void;

	@:overload
	public static function arc(drawmode:Dynamic, arctype:Dynamic, x:Float, y:Float, radius:Float, angle1:Float, angle2:Float, segments:Float = 10): Void;

	@:overload
	public static function captureScreenshot(filename:String): Void;

	@:overload
	public static function captureScreenshot(callback:Dynamic): Void;

	@:overload
	public static function captureScreenshot(channel:Dynamic): Void;

	@:overload
	public static function circle(mode:Dynamic, x:Float, y:Float, radius:Float): Void;

	@:overload
	public static function circle(mode:Dynamic, x:Float, y:Float, radius:Float, segments:Float): Void;

	@:overload
	public static function clear(): Void;

	@:overload
	public static function clear(r:Float, g:Float, b:Float, a:Float = 1, clearstencil:Bool = true, cleardepth:Bool = true): Void;

	@:overload
	public static function clear(color:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>, clearstencil:Bool = true, cleardepth:Bool = true): Void;

	@:overload
	public static function clear(clearcolor:Bool, clearstencil:Bool, cleardepth:Bool): Void;

	@:overload
	public static function discard(discardcolor:Bool = true, discardstencil:Bool = true): Void;

	@:overload
	public static function discard(discardcolors:Table<Dynamic,Dynamic>, discardstencil:Bool = true): Void;

	@:overload
	public static function draw(drawable:Dynamic, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function draw(texture:Dynamic, quad:Dynamic, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function draw(drawable:Dynamic, transform:Dynamic): Void;

	@:overload
	public static function draw(texture:Dynamic, quad:Dynamic, transform:Dynamic): Void;

	@:overload
	public static function drawInstanced(mesh:Dynamic, instancecount:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawInstanced(mesh:Dynamic, instancecount:Float, transform:Dynamic): Void;

	@:overload
	public static function drawLayer(texture:Dynamic, layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawLayer(texture:Dynamic, layerindex:Float, quad:Dynamic, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function drawLayer(texture:Dynamic, layerindex:Float, transform:Dynamic): Void;

	@:overload
	public static function drawLayer(texture:Dynamic, layerindex:Float, quad:Dynamic, transform:Dynamic): Void;

	@:overload
	public static function ellipse(mode:Dynamic, x:Float, y:Float, radiusx:Float, radiusy:Float): Void;

	@:overload
	public static function ellipse(mode:Dynamic, x:Float, y:Float, radiusx:Float, radiusy:Float, segments:Float): Void;

	public static function flushBatch(): Void;

	public static function getBackgroundColor(): BackgroundColor;

	public static function getBlendMode(): BlendMode;

	public static function getCanvas(): Dynamic;

	@:overload
	public static function getCanvasFormats(): Table<Dynamic,Dynamic>;

	@:overload
	public static function getCanvasFormats(readable:Bool): Table<Dynamic,Dynamic>;

	public static function getColor(): Color;

	public static function getColorMask(): ColorMask;

	public static function getDPIScale(): Float;

	public static function getDefaultFilter(): DefaultFilter;

	public static function getDepthMode(): DepthMode;

	public static function getDimensions(): Dimensions;

	public static function getFont(): Dynamic;

	public static function getFrontFaceWinding(): Dynamic;

	public static function getHeight(): Float;

	public static function getImageFormats(): Table<Dynamic,Dynamic>;

	public static function getLineJoin(): Dynamic;

	public static function getLineStyle(): Dynamic;

	public static function getLineWidth(): Float;

	public static function getMeshCullMode(): Dynamic;

	public static function getPixelDimensions(): PixelDimensions;

	public static function getPixelHeight(): Float;

	public static function getPixelWidth(): Float;

	public static function getPointSize(): Float;

	public static function getRendererInfo(): RendererInfo;

	public static function getScissor(): Scissor;

	public static function getShader(): Dynamic;

	public static function getStackDepth(): Float;

	@:overload
	public static function getStats(): Table<Dynamic,Dynamic>;

	@:overload
	public static function getStats(stats:Table<Dynamic,Dynamic>): Table<Dynamic,Dynamic>;

	public static function getStencilTest(): StencilTest;

	public static function getSupported(): Table<Dynamic,Dynamic>;

	public static function getSystemLimits(): Table<Dynamic,Dynamic>;

	public static function getTextureTypes(): Table<Dynamic,Dynamic>;

	public static function getWidth(): Float;

	public static function intersectScissor(x:Float, y:Float, width:Float, height:Float): Void;

	public static function inverseTransformPoint(screenX:Float, screenY:Float): InverseTransformPoint;

	public static function isActive(): Bool;

	public static function isGammaCorrect(): Bool;

	public static function isWireframe(): Bool;

	@:overload
	public static function line(x1:Float, y1:Float, x2:Float, y2:Float, ...:Float): Void;

	@:overload
	public static function line(points:Table<Dynamic,Dynamic>): Void;

	public static function newArrayImage(slices:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Dynamic;

	@:overload
	public static function newCanvas(): Dynamic;

	@:overload
	public static function newCanvas(width:Float, height:Float): Dynamic;

	@:overload
	public static function newCanvas(width:Float, height:Float, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newCanvas(width:Float, height:Float, layers:Float, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newCubeImage(filename:String, settings:Table<Dynamic,Dynamic> = nil): Dynamic;

	@:overload
	public static function newCubeImage(faces:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Dynamic;

	@:overload
	public static function newFont(filename:String): Dynamic;

	@:overload
	public static function newFont(filename:String, size:Float, hinting:Dynamic = 'normal', dpiscale:Float = love.graphics.getDPIScale()): Dynamic;

	@:overload
	public static function newFont(filename:String, imagefilename:String): Dynamic;

	@:overload
	public static function newFont(size:Float = 12, hinting:Dynamic = 'normal', dpiscale:Float = love.graphics.getDPIScale()): Dynamic;

	@:overload
	public static function newImage(filename:String, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newImage(fileData:Dynamic, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newImage(imageData:Dynamic, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newImage(compressedImageData:Dynamic, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newImageFont(filename:String, glyphs:String): Dynamic;

	@:overload
	public static function newImageFont(imageData:Dynamic, glyphs:String): Dynamic;

	@:overload
	public static function newImageFont(filename:String, glyphs:String, extraspacing:Float): Dynamic;

	@:overload
	public static function newMesh(vertices:Table<Dynamic,Dynamic>, mode:Dynamic = 'fan', usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newMesh(vertexcount:Float, mode:Dynamic = 'fan', usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newMesh(vertexformat:Table<Dynamic,Dynamic>, vertices:Table<Dynamic,Dynamic>, mode:Dynamic = 'fan', usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newMesh(vertexformat:Table<Dynamic,Dynamic>, vertexcount:Float, mode:Dynamic = 'fan', usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newMesh(vertexcount:Float, texture:Dynamic = nil, mode:Dynamic = 'fan'): Dynamic;

	@:overload
	public static function newParticleSystem(image:Dynamic, buffer:Float = 1000): Dynamic;

	@:overload
	public static function newParticleSystem(texture:Dynamic, buffer:Float = 1000): Dynamic;

	@:overload
	public static function newQuad(x:Float, y:Float, width:Float, height:Float, sw:Float, sh:Float): Dynamic;

	@:overload
	public static function newQuad(x:Float, y:Float, width:Float, height:Float, texture:Dynamic): Dynamic;

	@:overload
	public static function newShader(code:String): Dynamic;

	@:overload
	public static function newShader(pixelcode:String, vertexcode:String): Dynamic;

	@:overload
	public static function newSpriteBatch(image:Dynamic, maxsprites:Float = 1000): Dynamic;

	@:overload
	public static function newSpriteBatch(image:Dynamic, maxsprites:Float = 1000, usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newSpriteBatch(texture:Dynamic, maxsprites:Float = 1000, usage:Dynamic = 'dynamic'): Dynamic;

	@:overload
	public static function newText(font:Dynamic, textstring:String = nil): Dynamic;

	@:overload
	public static function newText(font:Dynamic, coloredtext:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newVideo(filename:String): Dynamic;

	@:overload
	public static function newVideo(videostream:Dynamic): Dynamic;

	@:overload
	public static function newVideo(filename:String, settings:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newVideo(filename:String, loadaudio:Bool = nil): Dynamic;

	@:overload
	public static function newVideo(videostream:Dynamic, loadaudio:Bool = nil): Dynamic;

	public static function newVolumeImage(layers:Table<Dynamic,Dynamic>, settings:Table<Dynamic,Dynamic> = nil): Dynamic;

	public static function origin(): Void;

	@:overload
	public static function points(x:Float, y:Float, ...:Float): Void;

	@:overload
	public static function points(points:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function points(points:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function polygon(mode:Dynamic, ...:Float): Void;

	@:overload
	public static function polygon(mode:Dynamic, vertices:Table<Dynamic,Dynamic>): Void;

	public static function pop(): Void;

	public static function present(): Void;

	@:overload
	public static function print(text:String, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function print(text:String, transform:Dynamic): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, transform:Dynamic): Void;

	@:overload
	public static function print(text:String, font:Dynamic, transform:Dynamic): Void;

	@:overload
	public static function print(coloredtext:Table<Dynamic,Dynamic>, font:Dynamic, transform:Dynamic): Void;

	@:overload
	public static function printf(text:String, x:Float, y:Float, limit:Float, align:Dynamic = 'left', r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(text:String, font:Dynamic, x:Float, y:Float, limit:Float, align:Dynamic = 'left', r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(text:String, transform:Dynamic, limit:Float, align:Dynamic = 'left'): Void;

	@:overload
	public static function printf(text:String, font:Dynamic, transform:Dynamic, limit:Float, align:Dynamic = 'left'): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, x:Float, y:Float, limit:Float, align:Dynamic, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, font:Dynamic, x:Float, y:Float, limit:Float, align:Dynamic = 'left', angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, transform:Dynamic, limit:Float, align:Dynamic = 'left'): Void;

	@:overload
	public static function printf(coloredtext:Table<Dynamic,Dynamic>, font:Dynamic, transform:Dynamic, limit:Float, align:Dynamic = 'left'): Void;

	@:overload
	public static function push(): Void;

	@:overload
	public static function push(stack:Dynamic): Void;

	@:overload
	public static function rectangle(mode:Dynamic, x:Float, y:Float, width:Float, height:Float): Void;

	@:overload
	public static function rectangle(mode:Dynamic, x:Float, y:Float, width:Float, height:Float, rx:Float, ry:Float = rx, segments:Float = nil): Void;

	public static function replaceTransform(transform:Dynamic): Void;

	public static function reset(): Void;

	public static function rotate(angle:Float): Void;

	public static function scale(sx:Float, sy:Float = sx): Void;

	@:overload
	public static function setBackgroundColor(red:Float, green:Float, blue:Float, alpha:Float = 1): Void;

	@:overload
	public static function setBackgroundColor(rgba:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setBlendMode(mode:Dynamic): Void;

	@:overload
	public static function setBlendMode(mode:Dynamic, alphamode:Dynamic = 'alphamultiply'): Void;

	@:overload
	public static function setCanvas(canvas:Dynamic, mipmap:Float = 1): Void;

	@:overload
	public static function setCanvas(): Void;

	@:overload
	public static function setCanvas(canvas1:Dynamic, canvas2:Dynamic, ...:Dynamic): Void;

	@:overload
	public static function setCanvas(canvas:Dynamic, slice:Float, mipmap:Float = 1): Void;

	@:overload
	public static function setCanvas(setup:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setColor(red:Float, green:Float, blue:Float, alpha:Float = 1): Void;

	@:overload
	public static function setColor(rgba:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setColorMask(red:Bool, green:Bool, blue:Bool, alpha:Bool): Void;

	@:overload
	public static function setColorMask(): Void;

	public static function setDefaultFilter(min:Dynamic, mag:Dynamic = min, anisotropy:Float = 1): Void;

	@:overload
	public static function setDepthMode(comparemode:Dynamic, write:Bool): Void;

	@:overload
	public static function setDepthMode(): Void;

	public static function setFont(font:Dynamic): Void;

	public static function setFrontFaceWinding(winding:Dynamic): Void;

	public static function setLineJoin(join:Dynamic): Void;

	public static function setLineStyle(style:Dynamic): Void;

	public static function setLineWidth(width:Float): Void;

	public static function setMeshCullMode(mode:Dynamic): Void;

	@:overload
	public static function setNewFont(size:Float = 12): Dynamic;

	@:overload
	public static function setNewFont(filename:String, size:Float = 12): Dynamic;

	@:overload
	public static function setNewFont(file:Dynamic, size:Float = 12): Dynamic;

	@:overload
	public static function setNewFont(data:Dynamic, size:Float = 12): Dynamic;

	@:overload
	public static function setNewFont(rasterizer:Dynamic): Dynamic;

	public static function setPointSize(size:Float): Void;

	@:overload
	public static function setScissor(x:Float, y:Float, width:Float, height:Float): Void;

	@:overload
	public static function setScissor(): Void;

	@:overload
	public static function setShader(shader:Dynamic): Void;

	@:overload
	public static function setShader(): Void;

	@:overload
	public static function setStencilTest(comparemode:Dynamic, comparevalue:Float): Void;

	@:overload
	public static function setStencilTest(): Void;

	public static function setWireframe(enable:Bool): Void;

	public static function shear(kx:Float, ky:Float): Void;

	public static function stencil(stencilfunction:Dynamic, action:Dynamic = 'replace', value:Float = 1, keepvalues:Bool = false): Void;

	public static function transformPoint(globalX:Float, globalY:Float): TransformPoint;

	public static function translate(dx:Float, dy:Float): Void;

	@:overload
	public static function validateShader(gles:Bool, code:String): ValidateShader;

	@:overload
	public static function validateShader(gles:Bool, pixelcode:String, vertexcode:String): ValidateShader;

}

extern public class BackgroundColor {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern public class BlendMode {
	public var mode:Dynamic;
	public var alphamode:Dynamic;
}

extern public class Color {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern public class ColorMask {
	public var r:Bool;
	public var g:Bool;
	public var b:Bool;
	public var a:Bool;
}

extern public class DefaultFilter {
	public var min:Dynamic;
	public var mag:Dynamic;
	public var anisotropy:Float;
}

extern public class DepthMode {
	public var comparemode:Dynamic;
	public var write:Bool;
}

extern public class Dimensions {
	public var width:Float;
	public var height:Float;
}

extern public class PixelDimensions {
	public var pixelwidth:Float;
	public var pixelheight:Float;
}

extern public class RendererInfo {
	public var name:String;
	public var version:String;
	public var vendor:String;
	public var device:String;
}

extern public class Scissor {
	public var x:Float;
	public var y:Float;
	public var width:Float;
	public var height:Float;
}

extern public class StencilTest {
	public var comparemode:Dynamic;
	public var comparevalue:Float;
}

extern public class InverseTransformPoint {
	public var globalX:Float;
	public var globalY:Float;
}

extern public class TransformPoint {
	public var screenX:Float;
	public var screenY:Float;
}

extern public class ValidateShader {
	public var status:Bool;
	public var message:String;
}

extern public class ValidateShader {
	public var status:Bool;
	public var message:String;
}

extern class Canvas extends Texture {

	public static function generateMipmaps(): Void;

	public static function getMSAA(): Float;

	public static function getMipmapMode(): Dynamic;

	@:overload
	public static function newImageData(): Dynamic;

	@:overload
	public static function newImageData(slice:Float, mipmap:Float = 1, x:Float, y:Float, width:Float, height:Float): Dynamic;

	public static function renderTo(func:Dynamic): Void;

}

extern class Drawable extends Object {

}

extern class Font extends Object {

	public static function getAscent(): Float;

	public static function getBaseline(): Float;

	public static function getDPIScale(): Float;

	public static function getDescent(): Float;

	public static function getFilter(): Filter;

	public static function getHeight(): Float;

	@:overload
	public static function getKerning(leftchar:String, rightchar:String): Float;

	@:overload
	public static function getKerning(leftglyph:Float, rightglyph:Float): Float;

	public static function getLineHeight(): Float;

	public static function getWidth(text:String): Float;

	public static function getWrap(text:String, wraplimit:Float): Wrap;

	@:overload
	public static function hasGlyphs(text:String): Bool;

	@:overload
	public static function hasGlyphs(character1:String, character2:String): Bool;

	@:overload
	public static function hasGlyphs(codepoint1:Float, codepoint2:Float): Bool;

	public static function setFallbacks(fallbackfont1:Dynamic, ...:Dynamic): Void;

	public static function setFilter(min:Dynamic, mag:Dynamic, anisotropy:Float = 1): Void;

	public static function setLineHeight(height:Float): Void;

}

extern class Image extends Texture {

	public static function getFlags(): Table<Dynamic,Dynamic>;

	public static function isCompressed(): Bool;

	public static function replacePixels(data:Dynamic, slice:Float, mipmap:Float = 1, x:Float = 0, y:Float = 0, reloadmipmaps:Bool): Void;

}

extern class Mesh extends Drawable {

	@:overload
	public static function attachAttribute(name:String, mesh:Dynamic): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Dynamic, step:Dynamic = 'pervertex', attachname:String = name): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Dynamic): Void;

	@:overload
	public static function attachAttribute(name:String, mesh:Dynamic, step:Dynamic = 'pervertex', attachname:String = name): Void;

	public static function detachAttribute(name:String): Bool;

	public static function getDrawMode(): Dynamic;

	public static function getDrawRange(): DrawRange;

	public static function getTexture(): Dynamic;

	@:overload
	public static function getVertex(index:Float): Vertex;

	@:overload
	public static function getVertex(index:Float): Vertex;

	public static function getVertexAttribute(vertexindex:Float, attributeindex:Float): VertexAttribute;

	public static function getVertexCount(): Float;

	public static function getVertexFormat(): Table<Dynamic,Dynamic>;

	public static function getVertexMap(): Table<Dynamic,Dynamic>;

	public static function isAttributeEnabled(name:String): Bool;

	public static function setAttributeEnabled(name:String, enable:Bool): Void;

	public static function setDrawMode(mode:Dynamic): Void;

	@:overload
	public static function setDrawRange(start:Float, count:Float): Void;

	@:overload
	public static function setDrawRange(): Void;

	@:overload
	public static function setTexture(texture:Dynamic): Void;

	@:overload
	public static function setTexture(): Void;

	@:overload
	public static function setVertex(index:Float, attributecomponent:Float, ...:Float): Void;

	@:overload
	public static function setVertex(index:Float, vertex:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setVertex(index:Float, x:Float, y:Float, u:Float, v:Float, r:Float = 1, g:Float = 1, b:Float = 1, a:Float = 1): Void;

	@:overload
	public static function setVertex(index:Float, vertex:Table<Dynamic,Dynamic>): Void;

	public static function setVertexAttribute(vertexindex:Float, attributeindex:Float, value1:Float, value2:Float, ...:Float): Void;

	@:overload
	public static function setVertexMap(map:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function setVertexMap(vi1:Float, vi2:Float, vi3:Float): Void;

	@:overload
	public static function setVertexMap(data:Dynamic, datatype:Dynamic): Void;

	@:overload
	public static function setVertices(vertices:Table<Dynamic,Dynamic>, startvertex:Float = 1, count:Float = all): Void;

	@:overload
	public static function setVertices(data:Dynamic, startvertex:Float = 1): Void;

	@:overload
	public static function setVertices(vertices:Table<Dynamic,Dynamic>): Void;

}

extern class ParticleSystem extends Drawable {

	public static function clone(): Dynamic;

	public static function emit(numparticles:Float): Void;

	public static function getBufferSize(): Float;

	public static function getColors(): Colors;

	public static function getCount(): Float;

	public static function getDirection(): Float;

	public static function getEmissionArea(): EmissionArea;

	public static function getEmissionRate(): Float;

	public static function getEmitterLifetime(): Float;

	public static function getInsertMode(): Dynamic;

	public static function getLinearAcceleration(): LinearAcceleration;

	public static function getLinearDamping(): LinearDamping;

	public static function getOffset(): Offset;

	public static function getParticleLifetime(): ParticleLifetime;

	public static function getPosition(): Position;

	public static function getQuads(): Table<Dynamic,Dynamic>;

	public static function getRadialAcceleration(): RadialAcceleration;

	public static function getRotation(): Rotation;

	public static function getSizeVariation(): Float;

	public static function getSizes(): Sizes;

	public static function getSpeed(): Speed;

	public static function getSpin(): Spin;

	public static function getSpinVariation(): Float;

	public static function getSpread(): Float;

	public static function getTangentialAcceleration(): TangentialAcceleration;

	public static function getTexture(): Dynamic;

	public static function hasRelativeRotation(): Bool;

	public static function isActive(): Bool;

	public static function isPaused(): Bool;

	public static function isStopped(): Bool;

	public static function moveTo(x:Float, y:Float): Void;

	public static function pause(): Void;

	public static function reset(): Void;

	public static function setBufferSize(size:Float): Void;

	@:overload
	public static function setColors(r1:Float, g1:Float, b1:Float, a1:Float = 1, r2:Float = nil, g2:Float = nil, b2:Float = nil, a2:Float = 1, r8:Float = nil, g8:Float = nil, b8:Float = nil, a8:Float = 1): Void;

	@:overload
	public static function setColors(rgba1:Table<Dynamic,Dynamic>, rgba2:Table<Dynamic,Dynamic> = nil, rgba8:Table<Dynamic,Dynamic> = nil): Void;

	public static function setDirection(direction:Float): Void;

	public static function setEmissionArea(distribution:Dynamic, dx:Float, dy:Float, angle:Float = 0, directionRelativeToCenter:Bool = false): Void;

	public static function setEmissionRate(rate:Float): Void;

	public static function setEmitterLifetime(life:Float): Void;

	public static function setInsertMode(mode:Dynamic): Void;

	public static function setLinearAcceleration(xmin:Float, ymin:Float, xmax:Float = xmin, ymax:Float = ymin): Void;

	public static function setLinearDamping(min:Float, max:Float = min): Void;

	public static function setOffset(x:Float, y:Float): Void;

	public static function setParticleLifetime(min:Float, max:Float = min): Void;

	public static function setPosition(x:Float, y:Float): Void;

	@:overload
	public static function setQuads(quad1:Dynamic, quad2:Dynamic): Void;

	@:overload
	public static function setQuads(quads:Table<Dynamic,Dynamic>): Void;

	public static function setRadialAcceleration(min:Float, max:Float = min): Void;

	public static function setRelativeRotation(enable:Bool): Void;

	public static function setRotation(min:Float, max:Float = min): Void;

	public static function setSizeVariation(variation:Float): Void;

	public static function setSizes(size1:Float, size2:Float = nil, size8:Float = nil): Void;

	public static function setSpeed(min:Float, max:Float = min): Void;

	public static function setSpin(min:Float, max:Float = min): Void;

	public static function setSpinVariation(variation:Float): Void;

	public static function setSpread(spread:Float): Void;

	public static function setTangentialAcceleration(min:Float, max:Float = min): Void;

	public static function setTexture(texture:Dynamic): Void;

	public static function start(): Void;

	public static function stop(): Void;

	public static function update(dt:Float): Void;

}

extern class Quad extends Object {

	public static function getTextureDimensions(): TextureDimensions;

	public static function getViewport(): Viewport;

	public static function setViewport(x:Float, y:Float, w:Float, h:Float, sw:Float, sh:Float): Void;

}

extern class Shader extends Object {

	public static function getWarnings(): String;

	public static function hasUniform(name:String): Bool;

	@:overload
	public static function send(name:String, number:Float, ...:Float): Void;

	@:overload
	public static function send(name:String, vector:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, matrix:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, texture:Dynamic): Void;

	@:overload
	public static function send(name:String, boolean:Bool, ...:Bool): Void;

	@:overload
	public static function send(name:String, matrixlayout:Dynamic, matrix:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

	@:overload
	public static function send(name:String, data:Dynamic, offset:Float = 0, size:Float = all): Void;

	@:overload
	public static function send(name:String, data:Dynamic, matrixlayout:Dynamic, offset:Float = 0, size:Float = all): Void;

	@:overload
	public static function send(name:String, matrixlayout:Dynamic, data:Dynamic, offset:Float = 0, size:Float = all): Void;

	public static function sendColor(name:String, color:Table<Dynamic,Dynamic>, ...:Table<Dynamic,Dynamic>): Void;

}

extern class SpriteBatch extends Drawable {

	@:overload
	public static function add(x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function add(quad:Dynamic, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, quad:Dynamic, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addLayer(layerindex:Float, transform:Dynamic): Float;

	@:overload
	public static function addLayer(layerindex:Float, quad:Dynamic, transform:Dynamic): Float;

	public static function attachAttribute(name:String, mesh:Dynamic): Void;

	public static function clear(): Void;

	public static function flush(): Void;

	public static function getBufferSize(): Float;

	public static function getColor(): Color;

	public static function getCount(): Float;

	public static function getTexture(): Dynamic;

	@:overload
	public static function set(spriteindex:Float, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function set(spriteindex:Float, quad:Dynamic, x:Float, y:Float, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setColor(r:Float, g:Float, b:Float, a:Float = 1): Void;

	@:overload
	public static function setColor(): Void;

	@:overload
	public static function setDrawRange(start:Float, count:Float): Void;

	@:overload
	public static function setDrawRange(): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, quad:Dynamic, x:Float = 0, y:Float = 0, r:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, transform:Dynamic): Void;

	@:overload
	public static function setLayer(spriteindex:Float, layerindex:Float, quad:Dynamic, transform:Dynamic): Void;

	public static function setTexture(texture:Dynamic): Void;

}

extern class Text extends Drawable {

	@:overload
	public static function add(textstring:String, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function add(coloredtext:Table<Dynamic,Dynamic>, x:Float = 0, y:Float = 0, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addf(textstring:String, wraplimit:Float, align:Dynamic, x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	@:overload
	public static function addf(coloredtext:Table<Dynamic,Dynamic>, wraplimit:Float, align:Dynamic, x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Float;

	public static function clear(): Void;

	@:overload
	public static function getDimensions(): Dimensions;

	@:overload
	public static function getDimensions(index:Float): Dimensions;

	public static function getFont(): Dynamic;

	@:overload
	public static function getHeight(): Float;

	@:overload
	public static function getHeight(index:Float): Float;

	@:overload
	public static function getWidth(): Float;

	@:overload
	public static function getWidth(index:Float): Float;

	@:overload
	public static function set(textstring:String): Void;

	@:overload
	public static function set(coloredtext:Table<Dynamic,Dynamic>): Void;

	public static function setFont(font:Dynamic): Void;

	@:overload
	public static function setf(textstring:String, wraplimit:Float, align:Dynamic): Void;

	@:overload
	public static function setf(coloredtext:Table<Dynamic,Dynamic>, wraplimit:Float, align:Dynamic): Void;

}

extern class Texture extends Drawable {

	public static function getDPIScale(): Float;

	public static function getDepth(): Float;

	public static function getDepthSampleMode(): Dynamic;

	public static function getDimensions(): Dimensions;

	public static function getFilter(): Filter;

	public static function getFormat(): Dynamic;

	public static function getHeight(): Float;

	public static function getLayerCount(): Float;

	public static function getMipmapCount(): Float;

	public static function getMipmapFilter(): MipmapFilter;

	public static function getPixelDimensions(): PixelDimensions;

	public static function getPixelHeight(): Float;

	public static function getPixelWidth(): Float;

	public static function getTextureType(): Dynamic;

	public static function getWidth(): Float;

	public static function getWrap(): Wrap;

	public static function isReadable(): Bool;

	public static function setDepthSampleMode(compare:Dynamic): Void;

	public static function setFilter(min:Dynamic, mag:Dynamic = min, anisotropy:Float = 1): Void;

	@:overload
	public static function setMipmapFilter(filtermode:Dynamic, sharpness:Float = 0): Void;

	@:overload
	public static function setMipmapFilter(): Void;

	public static function setWrap(horiz:Dynamic, vert:Dynamic = horiz, depth:Dynamic = horiz): Void;

}

extern class Video extends Drawable {

	public static function getDimensions(): Dimensions;

	public static function getFilter(): Filter;

	public static function getHeight(): Float;

	public static function getSource(): Dynamic;

	public static function getStream(): Dynamic;

	public static function getWidth(): Float;

	public static function isPlaying(): Bool;

	public static function pause(): Void;

	public static function play(): Void;

	public static function rewind(): Void;

	public static function seek(offset:Float): Void;

	public static function setFilter(min:Dynamic, mag:Dynamic, anisotropy:Float = 1): Void;

	public static function setSource(source:Dynamic = nil): Void;

	public static function tell(): Float;

}

enum abstract AlignMode {
	var Center = "center";
	var Left = "left";
	var Right = "right";
	var Justify = "justify";
}

enum abstract ArcType {
	var Pie = "pie";
	var Open = "open";
	var Closed = "closed";
}

enum abstract AreaSpreadDistribution {
	var Uniform = "uniform";
	var Normal = "normal";
	var Ellipse = "ellipse";
	var Borderellipse = "borderellipse";
	var Borderrectangle = "borderrectangle";
	var None = "none";
}

enum abstract BlendAlphaMode {
	var Alphamultiply = "alphamultiply";
	var Premultiplied = "premultiplied";
}

enum abstract BlendMode {
	var Alpha = "alpha";
	var Replace = "replace";
	var Screen = "screen";
	var Add = "add";
	var Subtract = "subtract";
	var Multiply = "multiply";
	var Lighten = "lighten";
	var Darken = "darken";
	var Additive = "additive";
	var Subtractive = "subtractive";
	var Multiplicative = "multiplicative";
	var Premultiplied = "premultiplied";
}

enum abstract CompareMode {
	var Equal = "equal";
	var Notequal = "notequal";
	var Less = "less";
	var Lequal = "lequal";
	var Gequal = "gequal";
	var Greater = "greater";
	var Never = "never";
	var Always = "always";
}

enum abstract CullMode {
	var Back = "back";
	var Front = "front";
	var None = "none";
}

enum abstract DrawMode {
	var Fill = "fill";
	var Line = "line";
}

enum abstract FilterMode {
	var Linear = "linear";
	var Nearest = "nearest";
}

enum abstract GraphicsFeature {
	var Clampzero = "clampzero";
	var Lighten = "lighten";
	var Multicanvasformats = "multicanvasformats";
	var Glsl3 = "glsl3";
	var Instancing = "instancing";
	var Fullnpot = "fullnpot";
	var Pixelshaderhighp = "pixelshaderhighp";
	var Shaderderivatives = "shaderderivatives";
}

enum abstract GraphicsLimit {
	var Pointsize = "pointsize";
	var Texturesize = "texturesize";
	var Multicanvas = "multicanvas";
	var Canvasmsaa = "canvasmsaa";
	var Texturelayers = "texturelayers";
	var Volumetexturesize = "volumetexturesize";
	var Cubetexturesize = "cubetexturesize";
	var Anisotropy = "anisotropy";
}

enum abstract IndexDataType {
	var Uint16 = "uint16";
	var Uint32 = "uint32";
}

enum abstract LineJoin {
	var Miter = "miter";
	var None = "none";
	var Bevel = "bevel";
}

enum abstract LineStyle {
	var Rough = "rough";
	var Smooth = "smooth";
}

enum abstract MeshDrawMode {
	var Fan = "fan";
	var Strip = "strip";
	var Triangles = "triangles";
	var Points = "points";
}

enum abstract MipmapMode {
	var None = "none";
	var Auto = "auto";
	var Manual = "manual";
}

enum abstract ParticleInsertMode {
	var Top = "top";
	var Bottom = "bottom";
	var Random = "random";
}

enum abstract SpriteBatchUsage {
	var Dynamic = "dynamic";
	var Static = "static";
	var Stream = "stream";
}

enum abstract StackType {
	var Transform = "transform";
	var All = "all";
}

enum abstract StencilAction {
	var Replace = "replace";
	var Increment = "increment";
	var Decrement = "decrement";
	var Incrementwrap = "incrementwrap";
	var Decrementwrap = "decrementwrap";
	var Invert = "invert";
}

enum abstract TextureType {
	var 2d = "2d";
	var Array = "array";
	var Cube = "cube";
	var Volume = "volume";
}

enum abstract VertexAttributeStep {
	var Pervertex = "pervertex";
	var Perinstance = "perinstance";
}

enum abstract VertexWinding {
	var Cw = "cw";
	var Ccw = "ccw";
}

enum abstract WrapMode {
	var Clamp = "clamp";
	var Repeat = "repeat";
	var Mirroredrepeat = "mirroredrepeat";
	var Clampzero = "clampzero";
}

