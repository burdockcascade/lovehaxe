// DO NOT EDIT THIS FILE
// GENERATED ON 2024-05-04 00:04:23

package love.math;

import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

@:native("love.math")
extern class Math {

	public static function colorFromBytes(rb:Float, gb:Float, bb:Float, ab:Float = null): ColorFromBytesResult;

	public static function colorToBytes(r:Float, g:Float, b:Float, a:Float = null): ColorToBytesResult;

	@:overload
	public static function compress(rawstring:String, format:Dynamic = Dynamic, level:Float = Dynamic): Dynamic;

	@:overload
	public static function compress(data:Dynamic, format:Dynamic = Dynamic, level:Float = Dynamic): Dynamic;

	@:overload
	public static function decompress(compressedData:Dynamic): String;

	@:overload
	public static function decompress(compressedstring:String, format:Dynamic): String;

	@:overload
	public static function decompress(data:Dynamic, format:Dynamic): String;

	@:overload
	public static function gammaToLinear(r:Float, g:Float, b:Float): GammaToLinearResult;

	@:overload
	public static function gammaToLinear(color:Table<Dynamic,Dynamic>): GammaToLinearResult;

	@:overload
	public static function gammaToLinear(c:Float): Float;

	public static function getRandomSeed(): RandomSeedResult;

	public static function getRandomState(): String;

	@:overload
	public static function isConvex(vertices:Table<Dynamic,Dynamic>): Bool;

	@:overload
	public static function isConvex(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): Bool;

	@:overload
	public static function linearToGamma(lr:Float, lg:Float, lb:Float): LinearToGammaResult;

	@:overload
	public static function linearToGamma(color:Table<Dynamic,Dynamic>): LinearToGammaResult;

	@:overload
	public static function linearToGamma(lc:Float): Float;

	@:overload
	public static function newBezierCurve(vertices:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function newBezierCurve(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): Dynamic;

	@:overload
	public static function newRandomGenerator(): Dynamic;

	@:overload
	public static function newRandomGenerator(seed:Float): Dynamic;

	@:overload
	public static function newRandomGenerator(low:Float, high:Float): Dynamic;

	@:overload
	public static function newTransform(): Dynamic;

	@:overload
	public static function newTransform(x:Float, y:Float, angle:Float = Dynamic, sx:Float = Dynamic, sy:Float = Dynamic, ox:Float = Dynamic, oy:Float = Dynamic, kx:Float = Dynamic, ky:Float = Dynamic): Dynamic;

	@:overload
	public static function noise(x:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float, z:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float, z:Float, w:Float): Float;

	@:overload
	public static function random(): Float;

	@:overload
	public static function random(max:Float): Float;

	@:overload
	public static function random(min:Float, max:Float): Float;

	public static function randomNormal(stddev:Float = Dynamic, mean:Float = Dynamic): Float;

	@:overload
	public static function setRandomSeed(seed:Float): Void;

	@:overload
	public static function setRandomSeed(low:Float, high:Float): Void;

	public static function setRandomState(state:String): Void;

	@:overload
	public static function triangulate(polygon:Table<Dynamic,Dynamic>): Table<Dynamic,Dynamic>;

	@:overload
	public static function triangulate(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): Table<Dynamic,Dynamic>;

}

extern public class ColorFromBytesResult {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern public class ColorToBytesResult {
	public var rb:Float;
	public var gb:Float;
	public var bb:Float;
	public var ab:Float;
}

extern public class GammaToLinearResult {
	public var lr:Float;
	public var lg:Float;
	public var lb:Float;
}

extern public class GammaToLinearResult {
	public var lr:Float;
	public var lg:Float;
	public var lb:Float;
}

extern public class RandomSeedResult {
	public var low:Float;
	public var high:Float;
}

extern public class LinearToGammaResult {
	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

extern public class LinearToGammaResult {
	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

extern class BezierCurve extends Object {

	public static function evaluate(t:Float): EvaluateResult;

	public static function getControlPoint(i:Float): ControlPointResult;

	public static function getControlPointCount(): Float;

	public static function getDegree(): Float;

	public static function getDerivative(): Dynamic;

	public static function getSegment(startpoint:Float, endpoint:Float): Dynamic;

	public static function insertControlPoint(x:Float, y:Float, i:Float = Dynamic): Void;

	public static function removeControlPoint(index:Float): Void;

	public static function render(depth:Float = Dynamic): Table<Dynamic,Dynamic>;

	public static function renderSegment(startpoint:Float, endpoint:Float, depth:Float = Dynamic): Table<Dynamic,Dynamic>;

	public static function rotate(angle:Float, ox:Float = Dynamic, oy:Float = Dynamic): Void;

	public static function scale(s:Float, ox:Float = Dynamic, oy:Float = Dynamic): Void;

	public static function setControlPoint(i:Float, x:Float, y:Float): Void;

	public static function translate(dx:Float, dy:Float): Void;

}

extern class RandomGenerator extends Object {

	public static function getSeed(): SeedResult;

	public static function getState(): String;

	@:overload
	public static function random(): Float;

	@:overload
	public static function random(max:Float): Float;

	@:overload
	public static function random(min:Float, max:Float): Float;

	public static function randomNormal(stddev:Float = Dynamic, mean:Float = Dynamic): Float;

	@:overload
	public static function setSeed(seed:Float): Void;

	@:overload
	public static function setSeed(low:Float, high:Float): Void;

	public static function setState(state:String): Void;

}

extern class Transform extends Object {

	public static function apply(other:Dynamic): Dynamic;

	public static function clone(): Dynamic;

	public static function getMatrix(): MatrixResult;

	public static function inverse(): Dynamic;

	public static function inverseTransformPoint(localX:Float, localY:Float): InverseTransformPointResult;

	public static function isAffine2DTransform(): Bool;

	public static function reset(): Dynamic;

	public static function rotate(angle:Float): Dynamic;

	public static function scale(sx:Float, sy:Float = Dynamic): Dynamic;

	@:overload
	public static function setMatrix(e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float): Dynamic;

	@:overload
	public static function setMatrix(layout:Dynamic, e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float): Dynamic;

	@:overload
	public static function setMatrix(layout:Dynamic, matrix:Table<Dynamic,Dynamic>): Dynamic;

	@:overload
	public static function setMatrix(layout:Dynamic, matrix:Table<Dynamic,Dynamic>): Dynamic;

	public static function setTransformation(x:Float, y:Float, angle:Float = Dynamic, sx:Float = Dynamic, sy:Float = Dynamic, ox:Float = Dynamic, oy:Float = Dynamic, kx:Float = Dynamic, ky:Float = Dynamic): Dynamic;

	public static function shear(kx:Float, ky:Float): Dynamic;

	public static function transformPoint(globalX:Float, globalY:Float): TransformPointResult;

	public static function translate(dx:Float, dy:Float): Dynamic;

}

enum abstract MatrixLayout {
	var Row = "row";
	var Column = "column";
}

