// DO NOT EDIT THIS FILE
// GENERATED ON 2024-05-04 01:07:02

package love.math;

import haxe.extern.Rest;
import lua.Table;
import lua.UserData;

@:native("love.math")
extern class Math {

	public static function colorFromBytes(rb:Float, gb:Float, bb:Float, ab:Float = nil): ColorFromBytes;

	public static function colorToBytes(r:Float, g:Float, b:Float, a:Float = nil): ColorToBytes;

	@:overload
	public static function compress(rawstring:String, format:CompressedDataFormat = 'lz4', level:Float = -1): CompressedData;

	@:overload
	public static function compress(data:Data, format:CompressedDataFormat = 'lz4', level:Float = -1): CompressedData;

	@:overload
	public static function decompress(compressedData:CompressedData): String;

	@:overload
	public static function decompress(compressedstring:String, format:CompressedDataFormat): String;

	@:overload
	public static function decompress(data:Data, format:CompressedDataFormat): String;

	@:overload
	public static function gammaToLinear(r:Float, g:Float, b:Float): GammaToLinear;

	@:overload
	public static function gammaToLinear(color:Table<Dynamic,Dynamic>): GammaToLinear;

	@:overload
	public static function gammaToLinear(c:Float): Float;

	public static function getRandomSeed(): RandomSeed;

	public static function getRandomState(): String;

	@:overload
	public static function isConvex(vertices:Table<Dynamic,Dynamic>): Bool;

	@:overload
	public static function isConvex(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): Bool;

	@:overload
	public static function linearToGamma(lr:Float, lg:Float, lb:Float): LinearToGamma;

	@:overload
	public static function linearToGamma(color:Table<Dynamic,Dynamic>): LinearToGamma;

	@:overload
	public static function linearToGamma(lc:Float): Float;

	@:overload
	public static function newBezierCurve(vertices:Table<Dynamic,Dynamic>): BezierCurve;

	@:overload
	public static function newBezierCurve(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): BezierCurve;

	@:overload
	public static function newRandomGenerator(): RandomGenerator;

	@:overload
	public static function newRandomGenerator(seed:Float): RandomGenerator;

	@:overload
	public static function newRandomGenerator(low:Float, high:Float): RandomGenerator;

	@:overload
	public static function newTransform(): Transform;

	@:overload
	public static function newTransform(x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Transform;

	@:overload
	public static function noise(x:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float, z:Float): Float;

	@:overload
	public static function noise(x:Float, y:Float, z:Float, w:Float): Float;

	@:overload
	public static function random(): Float;

	@:overload
	public static function random(max:Float): Float;

	@:overload
	public static function random(min:Float, max:Float): Float;

	public static function randomNormal(stddev:Float = 1, mean:Float = 0): Float;

	@:overload
	public static function setRandomSeed(seed:Float): Void;

	@:overload
	public static function setRandomSeed(low:Float, high:Float): Void;

	public static function setRandomState(state:String): Void;

	@:overload
	public static function triangulate(polygon:Table<Dynamic,Dynamic>): Table<Dynamic,Dynamic>;

	@:overload
	public static function triangulate(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float): Table<Dynamic,Dynamic>;

}

extern public class ColorFromBytes {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern public class ColorToBytes {
	public var rb:Float;
	public var gb:Float;
	public var bb:Float;
	public var ab:Float;
}

extern public class GammaToLinear {
	public var lr:Float;
	public var lg:Float;
	public var lb:Float;
}

extern public class GammaToLinear {
	public var lr:Float;
	public var lg:Float;
	public var lb:Float;
}

extern public class RandomSeed {
	public var low:Float;
	public var high:Float;
}

extern public class LinearToGamma {
	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

extern public class LinearToGamma {
	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

extern class BezierCurve extends Object {

	public static function evaluate(t:Float): Evaluate;

	public static function getControlPoint(i:Float): ControlPoint;

	public static function getControlPointCount(): Float;

	public static function getDegree(): Float;

	public static function getDerivative(): BezierCurve;

	public static function getSegment(startpoint:Float, endpoint:Float): BezierCurve;

	public static function insertControlPoint(x:Float, y:Float, i:Float = -1): Void;

	public static function removeControlPoint(index:Float): Void;

	public static function render(depth:Float = 5): Table<Dynamic,Dynamic>;

	public static function renderSegment(startpoint:Float, endpoint:Float, depth:Float = 5): Table<Dynamic,Dynamic>;

	public static function rotate(angle:Float, ox:Float = 0, oy:Float = 0): Void;

	public static function scale(s:Float, ox:Float = 0, oy:Float = 0): Void;

	public static function setControlPoint(i:Float, x:Float, y:Float): Void;

	public static function translate(dx:Float, dy:Float): Void;

}

extern class RandomGenerator extends Object {

	public static function getSeed(): Seed;

	public static function getState(): String;

	@:overload
	public static function random(): Float;

	@:overload
	public static function random(max:Float): Float;

	@:overload
	public static function random(min:Float, max:Float): Float;

	public static function randomNormal(stddev:Float = 1, mean:Float = 0): Float;

	@:overload
	public static function setSeed(seed:Float): Void;

	@:overload
	public static function setSeed(low:Float, high:Float): Void;

	public static function setState(state:String): Void;

}

extern class Transform extends Object {

	public static function apply(other:Transform): Transform;

	public static function clone(): Transform;

	public static function getMatrix(): Matrix;

	public static function inverse(): Transform;

	public static function inverseTransformPoint(localX:Float, localY:Float): InverseTransformPoint;

	public static function isAffine2DTransform(): Bool;

	public static function reset(): Transform;

	public static function rotate(angle:Float): Transform;

	public static function scale(sx:Float, sy:Float = sx): Transform;

	@:overload
	public static function setMatrix(e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float): Transform;

	@:overload
	public static function setMatrix(layout:MatrixLayout, e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float): Transform;

	@:overload
	public static function setMatrix(layout:MatrixLayout, matrix:Table<Dynamic,Dynamic>): Transform;

	@:overload
	public static function setMatrix(layout:MatrixLayout, matrix:Table<Dynamic,Dynamic>): Transform;

	public static function setTransformation(x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0): Transform;

	public static function shear(kx:Float, ky:Float): Transform;

	public static function transformPoint(globalX:Float, globalY:Float): TransformPoint;

	public static function translate(dx:Float, dy:Float): Transform;

}

enum abstract MatrixLayout {
	var Row = "row";
	var Column = "column";
}

