/*
 * This file was generated by the LOVE2D Haxe bindings generator for Love2D v11.4.
 * Do not modify this file directly.
 * 2024-05-05 23:35:57
 */

package love;

import lua.Table;
import love.Data.CompressedData;
import love.Love2D.Object;
import love.Data.Data;

extern class RandomGenerator extends Object {
	public static function getSeed():Seed;
	public static function getState():String;
	public static function random():Float;
	public static function randomNormal(stddev:Float = 1, mean:Float = 0):Float;
	public static function setSeed(seed:Float):Void;
	public static function setState(state:String):Void;
}

extern class ControlPoint {
	public var x:Float;
	public var y:Float;
}

extern class LinearToGammaResult {
	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

extern class ColorToBytesResult {
	public var rb:Float;
	public var gb:Float;
	public var bb:Float;
	public var ab:Float;
}

extern class InverseTransformPointResult {
	public var globalX:Float;
	public var globalY:Float;
}

extern class RandomSeed {
	public var low:Float;
	public var high:Float;
}

extern class Transform extends Object {
	public static function apply(other:Transform):Transform;
	public static function clone():Transform;
	public static function getMatrix():Matrix;
	public static function inverse():Transform;
	public static function inverseTransformPoint(localX:Float, localY:Float):InverseTransformPointResult;
	public static function isAffine2DTransform():Bool;
	public static function reset():Transform;
	public static function rotate(angle:Float):Transform;
	public static function scale(sx:Float, sy:Float = Sx):Transform;
	public static function setMatrix(e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float):Transform;
	public static function setTransformation(x:Float, y:Float, angle:Float = 0, sx:Float = 1, sy:Float = Sx, ox:Float = 0, oy:Float = 0, kx:Float = 0, ky:Float = 0):Transform;
	public static function shear(kx:Float, ky:Float):Transform;
	public static function transformPoint(globalX:Float, globalY:Float):TransformPointResult;
	public static function translate(dx:Float, dy:Float):Transform;
}

extern class Matrix {
	public var e1_1:Float;
	public var e1_2:Float;
	public var e1_3:Float;
	public var e1_4:Float;
	public var e2_1:Float;
	public var e2_2:Float;
	public var e2_3:Float;
	public var e2_4:Float;
	public var e3_1:Float;
	public var e3_2:Float;
	public var e3_3:Float;
	public var e3_4:Float;
	public var e4_1:Float;
	public var e4_2:Float;
	public var e4_3:Float;
	public var e4_4:Float;
}

extern class Math {
	public static function colorFromBytes(rb:Float, gb:Float, bb:Float, ab:Float = Null):ColorFromBytesResult;
	public static function colorToBytes(r:Float, g:Float, b:Float, a:Float = Null):ColorToBytesResult;
	public static function compress(rawstring:String, format:CompressedDataFormat = 'lz4', level:Float = -1):CompressedData;
	public static function decompress(compressedData:CompressedData):String;
	public static function gammaToLinear(r:Float, g:Float, b:Float):GammaToLinearResult;
	public static function getRandomSeed():RandomSeed;
	public static function getRandomState():String;
	public static function isConvex(vertices:Table<Dynamic,Dynamic>):Bool;
	public static function linearToGamma(lr:Float, lg:Float, lb:Float):LinearToGammaResult;
	public static function newBezierCurve(vertices:Table<Dynamic,Dynamic>):BezierCurve;
	public static function newRandomGenerator():RandomGenerator;
	public static function newTransform():Transform;
	public static function noise(x:Float):Float;
	public static function random():Float;
	public static function randomNormal(stddev:Float = 1, mean:Float = 0):Float;
	public static function setRandomSeed(seed:Float):Void;
	public static function setRandomState(state:String):Void;
	public static function triangulate(polygon:Table<Dynamic,Dynamic>):Table<Dynamic,Dynamic>;
}

extern class TransformPointResult {
	public var localX:Float;
	public var localY:Float;
}

extern class Seed {
	public var low:Float;
	public var high:Float;
}

extern class BezierCurve extends Object {
	public static function evaluate(t:Float):EvaluateResult;
	public static function getControlPoint(i:Float):ControlPoint;
	public static function getControlPointCount():Float;
	public static function getDegree():Float;
	public static function getDerivative():BezierCurve;
	public static function getSegment(startpoint:Float, endpoint:Float):BezierCurve;
	public static function insertControlPoint(x:Float, y:Float, i:Float = -1):Void;
	public static function removeControlPoint(index:Float):Void;
	public static function render(depth:Float = 5):Table<Dynamic,Dynamic>;
	public static function renderSegment(startpoint:Float, endpoint:Float, depth:Float = 5):Table<Dynamic,Dynamic>;
	public static function rotate(angle:Float, ox:Float = 0, oy:Float = 0):Void;
	public static function scale(s:Float, ox:Float = 0, oy:Float = 0):Void;
	public static function setControlPoint(i:Float, x:Float, y:Float):Void;
	public static function translate(dx:Float, dy:Float):Void;
}

extern class EvaluateResult {
	public var x:Float;
	public var y:Float;
}

extern class GammaToLinearResult {
	public var lr:Float;
	public var lg:Float;
	public var lb:Float;
}

extern class ColorFromBytesResult {
	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;
}

extern enum MatrixLayout {
	ROW;
	COLUMN;
}

