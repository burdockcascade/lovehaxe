/*
 * This file was generated by the LOVE2D Haxe bindings generator for Love2D v11.5.
 * Do not modify this file directly.
 * 2024-05-12 20:41:35
 */

package love;

import lua.Table;
import lua.UserData;
import love.Data.CompressedData;
import love.Love2D.Object;
import love.Love2D.Data;

@:multiReturn
extern class MathRandomSeed {

	public var high:Float;
	public var low:Float;
}

@:multiReturn
extern class MathColorToBytesResult {

	public var bb:Float;
	public var ab:Float;
	public var gb:Float;
	public var rb:Float;
}

extern class RandomGenerator extends Object {

	@:overload(function ():Float {})
	@:overload(function (max:Float):Float {})
	function random(min:Float, max:Float):Float;

	function setState(state:String):Void;

	function randomNormal(stddev:Float, mean:Float):Float;

	function getState():String;

	function new():Void;

	@:overload(function (seed:Float):Void {})
	function setSeed(low:Float, high:Float):Void;

	function getSeed():RandomGeneratorSeed;

}

@:multiReturn
extern class BezierCurveControlPoint {

	public var x:Float;
	public var y:Float;
}

@:multiReturn
extern class MathGammaToLinearResult {

	public var lg:Float;
	public var lb:Float;
	public var lr:Float;
}

@:native("love.math")
extern class MathModule {

	@:overload(function ():Float {})
	@:overload(function (max:Float):Float {})
	public static function random(min:Float, max:Float):Float;

	@:overload(function ():Dynamic {})
	@:overload(function (seed:Float):Dynamic {})
	public static function newRandomGenerator(low:Float, high:Float):Dynamic;

	@:overload(function (polygon:Table<Dynamic,Dynamic>):Table<Dynamic,Dynamic> {})
	public static function triangulate(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):Table<Dynamic,Dynamic>;

	public static function setRandomState(state:String):Void;

	public static function randomNormal(stddev:Float, mean:Float):Float;

	public static function getRandomState():String;

	@:overload(function (r:Float, g:Float, b:Float):MathGammaToLinearResult {})
	@:overload(function (color:Table<Dynamic,Dynamic>):MathGammaToLinearResult {})
	public static function gammaToLinear(c:Float):Float;

	@:overload(function (compressedData:CompressedData):String {})
	@:overload(function (compressedstring:String, format:Dynamic):String {})
	public static function decompress(data:Data, format:Dynamic):String;

	@:overload(function (vertices:Table<Dynamic,Dynamic>):BezierCurve {})
	public static function newBezierCurve(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):BezierCurve;

	@:overload(function (vertices:Table<Dynamic,Dynamic>):Bool {})
	public static function isConvex(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):Bool;

	public static function colorFromBytes(rb:Float, gb:Float, bb:Float, ab:Float):MathColorFromBytesResult;

	@:overload(function (seed:Float):Void {})
	public static function setRandomSeed(low:Float, high:Float):Void;

	@:overload(function (x:Float):Float {})
	@:overload(function (x:Float, y:Float):Float {})
	@:overload(function (x:Float, y:Float, z:Float):Float {})
	public static function noise(x:Float, y:Float, z:Float, w:Float):Float;

	@:overload(function (lr:Float, lg:Float, lb:Float):MathLinearToGammaResult {})
	@:overload(function (color:Table<Dynamic,Dynamic>):MathLinearToGammaResult {})
	public static function linearToGamma(lc:Float):Float;

	public static function getRandomSeed():MathRandomSeed;

	@:overload(function (rawstring:String, format:Dynamic, level:Float):CompressedData {})
	public static function compress(data:Data, format:Dynamic, level:Float):CompressedData;

	@:overload(function ():Dynamic {})
	public static function newTransform(x:Float, y:Float, angle:Float, sx:Float, sy:Float, ox:Float, oy:Float, kx:Float, ky:Float):Dynamic;

	public static function colorToBytes(r:Float, g:Float, b:Float, a:Float):MathColorToBytesResult;

}

extern class Transform extends Object {

	function transformPoint(globalX:Float, globalY:Float):TransformTransformPointResult;

	function shear(kx:Float, ky:Float):Dynamic;

	@:overload(function (e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float):Dynamic {})
	@:overload(function (layout:MatrixLayout, e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float):Dynamic {})
	@:overload(function (layout:MatrixLayout, matrix:Table<Dynamic,Dynamic>):Dynamic {})
	function setMatrix(layout:MatrixLayout, matrix:Table<Dynamic,Dynamic>):Dynamic;

	function inverseTransformPoint(localX:Float, localY:Float):TransformInverseTransformPointResult;

	function inverse():Dynamic;

	function getMatrix():TransformMatrix;

	function apply(other:Dynamic):Dynamic;

	function reset():Dynamic;

	function new():Void;

	function isAffine2DTransform():Bool;

	function translate(dx:Float, dy:Float):Dynamic;

	function clone():Dynamic;

	function scale(sx:Float, sy:Float):Dynamic;

	function rotate(angle:Float):Dynamic;

	function setTransformation(x:Float, y:Float, angle:Float, sx:Float, sy:Float, ox:Float, oy:Float, kx:Float, ky:Float):Dynamic;

}

@:multiReturn
extern class TransformTransformPointResult {

	public var localX:Float;
	public var localY:Float;
}

@:multiReturn
extern class TransformMatrix {

	public var e2_1:Float;
	public var e1_2:Float;
	public var e3_1:Float;
	public var e2_2:Float;
	public var e1_3:Float;
	public var e4_1:Float;
	public var e3_2:Float;
	public var e2_3:Float;
	public var e1_4:Float;
	public var e4_2:Float;
	public var e3_3:Float;
	public var e2_4:Float;
	public var e4_3:Float;
	public var e3_4:Float;
	public var e4_4:Float;
	public var e1_1:Float;
}

@:multiReturn
extern class RandomGeneratorSeed {

	public var high:Float;
	public var low:Float;
}

@:multiReturn
extern class BezierCurveEvaluateResult {

	public var x:Float;
	public var y:Float;
}

@:multiReturn
extern class MathLinearToGammaResult {

	public var cr:Float;
	public var cg:Float;
	public var cb:Float;
}

@:multiReturn
extern class TransformInverseTransformPointResult {

	public var globalX:Float;
	public var globalY:Float;
}

@:multiReturn
extern class MathColorFromBytesResult {

	public var b:Float;
	public var r:Float;
	public var g:Float;
	public var a:Float;
}

extern class BezierCurve extends Object {

	function getDerivative():BezierCurve;

	function getControlPointCount():Float;

	function new():Void;

	function getSegment(startpoint:Float, endpoint:Float):BezierCurve;

	function getControlPoint(i:Float):BezierCurveControlPoint;

	function translate(dx:Float, dy:Float):Void;

	function removeControlPoint(index:Float):Void;

	function evaluate(t:Float):BezierCurveEvaluateResult;

	function scale(s:Float, ox:Float, oy:Float):Void;

	function rotate(angle:Float, ox:Float, oy:Float):Void;

	function getDegree():Float;

	function setControlPoint(i:Float, x:Float, y:Float):Void;

	function renderSegment(startpoint:Float, endpoint:Float, depth:Float):Table<Dynamic,Dynamic>;

	function render(depth:Float):Table<Dynamic,Dynamic>;

	function insertControlPoint(x:Float, y:Float, i:Float):Void;

}

extern enum MatrixLayout {
	ROW;
	COLUMN;
}

