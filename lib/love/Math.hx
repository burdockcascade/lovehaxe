/*
 * This file was generated by the LOVE2D Haxe bindings generator.
 * Do not modify this file directly.
 * 2024-05-04 23:35:06
 */

package love;

@:native("love.math")
extern class Math {

	public static function colorFromBytes(rb:Float, gb:Float, bb:Float, ab:Float):ColorFromBytesResult;

	public static function colorToBytes(r:Float, g:Float, b:Float, a:Float):ColorToBytesResult;

	public static function compress(rawstring:String, format:CompressedDataFormat, level:Float):CompressedData;

	public static function compress(data:Data, format:CompressedDataFormat, level:Float):CompressedData;

	public static function decompress(compressedData:CompressedData):String;

	public static function decompress(compressedstring:String, format:CompressedDataFormat):String;

	public static function decompress(data:Data, format:CompressedDataFormat):String;

	public static function gammaToLinear(r:Float, g:Float, b:Float):GammaToLinearResult;

	public static function gammaToLinear(color:Dynamic):GammaToLinearResult;

	public static function gammaToLinear(c:Float):Float;

	public static function getRandomSeed():RandomSeed;

	public static function getRandomState():String;

	public static function isConvex(vertices:Dynamic):Bool;

	public static function isConvex(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):Bool;

	public static function linearToGamma(lr:Float, lg:Float, lb:Float):LinearToGammaResult;

	public static function linearToGamma(color:Dynamic):LinearToGammaResult;

	public static function linearToGamma(lc:Float):Float;

	public static function newBezierCurve(vertices:Dynamic):BezierCurve;

	public static function newBezierCurve(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):BezierCurve;

	public static function newRandomGenerator():RandomGenerator;

	public static function newRandomGenerator(seed:Float):RandomGenerator;

	public static function newRandomGenerator(low:Float, high:Float):RandomGenerator;

	public static function newTransform():Transform;

	public static function newTransform(x:Float, y:Float, angle:Float, sx:Float, sy:Float, ox:Float, oy:Float, kx:Float, ky:Float):Transform;

	public static function noise(x:Float):Float;

	public static function noise(x:Float, y:Float):Float;

	public static function noise(x:Float, y:Float, z:Float):Float;

	public static function noise(x:Float, y:Float, z:Float, w:Float):Float;

	public static function random():Float;

	public static function random(max:Float):Float;

	public static function random(min:Float, max:Float):Float;

	public static function randomNormal(stddev:Float, mean:Float):Float;

	public static function setRandomSeed(seed:Float):Void;

	public static function setRandomSeed(low:Float, high:Float):Void;

	public static function setRandomState(state:String):Void;

	public static function triangulate(polygon:Dynamic):Dynamic;

	public static function triangulate(x1:Float, y1:Float, x2:Float, y2:Float, x3:Float, y3:Float):Dynamic;

}

extern class BezierCurve {

	public static function evaluate(t:Float):EvaluateResult;

	public static function getControlPoint(i:Float):ControlPoint;

	public static function getControlPointCount():Float;

	public static function getDegree():Float;

	public static function getDerivative():BezierCurve;

	public static function getSegment(startpoint:Float, endpoint:Float):BezierCurve;

	public static function insertControlPoint(x:Float, y:Float, i:Float):Void;

	public static function removeControlPoint(index:Float):Void;

	public static function render(depth:Float):Dynamic;

	public static function renderSegment(startpoint:Float, endpoint:Float, depth:Float):Dynamic;

	public static function rotate(angle:Float, ox:Float, oy:Float):Void;

	public static function scale(s:Float, ox:Float, oy:Float):Void;

	public static function setControlPoint(i:Float, x:Float, y:Float):Void;

	public static function translate(dx:Float, dy:Float):Void;

}

extern class RandomGenerator {

	public static function getSeed():Seed;

	public static function getState():String;

	public static function random():Float;

	public static function random(max:Float):Float;

	public static function random(min:Float, max:Float):Float;

	public static function randomNormal(stddev:Float, mean:Float):Float;

	public static function setSeed(seed:Float):Void;

	public static function setSeed(low:Float, high:Float):Void;

	public static function setState(state:String):Void;

}

extern class Transform {

	public static function apply(other:Transform):Transform;

	public static function clone():Transform;

	public static function getMatrix():Matrix;

	public static function inverse():Transform;

	public static function inverseTransformPoint(localX:Float, localY:Float):InverseTransformPointResult;

	public static function isAffine2DTransform():Bool;

	public static function reset():Transform;

	public static function rotate(angle:Float):Transform;

	public static function scale(sx:Float, sy:Float):Transform;

	public static function setMatrix(e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float):Transform;

	public static function setMatrix(layout:MatrixLayout, e1_1:Float, e1_2:Float, e1_3:Float, e1_4:Float, e2_1:Float, e2_2:Float, e2_3:Float, e2_4:Float, e3_1:Float, e3_2:Float, e3_3:Float, e3_4:Float, e4_1:Float, e4_2:Float, e4_3:Float, e4_4:Float):Transform;

	public static function setMatrix(layout:MatrixLayout, matrix:Dynamic):Transform;

	public static function setMatrix(layout:MatrixLayout, matrix:Dynamic):Transform;

	public static function setTransformation(x:Float, y:Float, angle:Float, sx:Float, sy:Float, ox:Float, oy:Float, kx:Float, ky:Float):Transform;

	public static function shear(kx:Float, ky:Float):Transform;

	public static function transformPoint(globalX:Float, globalY:Float):TransformPointResult;

	public static function translate(dx:Float, dy:Float):Transform;

}

extern enum MatrixLayout {
	ROW;
	COLUMN;
}

extern class ColorFromBytesResult {

	public var r:Float;
	public var g:Float;
	public var b:Float;
	public var a:Float;

}

extern class ColorToBytesResult {

	public var rb:Float;
	public var gb:Float;
	public var bb:Float;
	public var ab:Float;

}

extern class GammaToLinearResult {

	public var lr:Float;
	public var lg:Float;
	public var lb:Float;

}

extern class GammaToLinearResult {

	public var lr:Float;
	public var lg:Float;
	public var lb:Float;

}

extern class RandomSeed {

	public var low:Float;
	public var high:Float;

}

extern class LinearToGammaResult {

	public var cr:Float;
	public var cg:Float;
	public var cb:Float;

}

extern class LinearToGammaResult {

	public var cr:Float;
	public var cg:Float;
	public var cb:Float;

}

extern class EvaluateResult {

	public var x:Float;
	public var y:Float;

}

extern class ControlPoint {

	public var x:Float;
	public var y:Float;

}

extern class Seed {

	public var low:Float;
	public var high:Float;

}

extern class Matrix {

	public var e1_1:Float;
	public var e1_2:Float;
	public var e1_3:Float;
	public var e1_4:Float;
	public var e2_1:Float;
	public var e2_2:Float;
	public var e2_3:Float;
	public var e2_4:Float;
	public var e3_1:Float;
	public var e3_2:Float;
	public var e3_3:Float;
	public var e3_4:Float;
	public var e4_1:Float;
	public var e4_2:Float;
	public var e4_3:Float;
	public var e4_4:Float;

}

extern class InverseTransformPointResult {

	public var globalX:Float;
	public var globalY:Float;

}

extern class TransformPointResult {

	public var localX:Float;
	public var localY:Float;

}

