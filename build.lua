local api = require "love-api.love_api"

local function capitalize(s)
	return s:sub(1, 1):upper() .. s:sub(2)
end

local function map_type(type)

    local type_map = {
        number = "Float",
        string = "String",
        boolean = "Bool",
        table = "Table<Dynamic,Dynamic>",
        ["light userdata"] = "UserData",
        userdata = "UserData",
        ["function"] = "Dynamic", -- FIXME
        mixed = "Dynamic",
        value = "Dynamic",
        any = "Dynamic",
        Variant = "Dynamic",
        ["nil"] = "null"
    }

    return type_map[type] or capitalize(type)
end

local function get_multi_return_class_name(func)
    -- function name without "get"
    if func.name:sub(1, 3) == "get" then
        return capitalize(func.name:sub(4))
    else
        return capitalize(func.name)
    end
end

local function output_function(file, func)

    -- every variant
    for i, variant in ipairs(func.variants) do

        -- write overload comment if more than one variant
        if #func.variants > 1 then
            file:write("\t@:overload\n")
        end

        -- write function name
        file:write("\tpublic static function " .. func.name .. "(")

        -- write arguments
        if variant.arguments then
            for j, arg in ipairs(variant.arguments) do
                file:write(arg.name .. ":" .. map_type(arg.type) .. (arg.default and " = " .. arg.default or "") .. "")

                -- write comma if not last argument
                if j < #variant.arguments then
                    file:write(", ")
                end
            end
        end

        -- write return type
        if variant.returns then
            if #variant.returns > 1 then
                file:write("): " .. capitalize(get_multi_return_class_name(func)) .. ";\n\n")
            else
                file:write("): " .. map_type(variant.returns[1].type) .. ";\n\n")
            end
        else
            file:write("): Void;\n\n")
        end
    end

end

local function output_multi_return_function(file, func)

    -- every variant
    for i, variant in ipairs(func.variants) do

        -- write return type
        if variant.returns and #variant.returns > 1 then
            
            -- function name without "get"
            result_name = get_multi_return_class_name(func)

            file:write("extern public class " .. capitalize(result_name) .. " {\n")

            for j, ret in ipairs(variant.returns) do
                file:write("\tpublic var " .. ret.name .. ":" .. map_type(ret.type) .. ";\n")
            end

            file:write("}\n\n")
        
        end
            
    end
end

local function output_type(file, type)
    -- write class
    file:write("extern class " .. capitalize(type.name))

    -- write parent class
    if type.supertypes then
        file:write(" extends " .. capitalize(type.supertypes[1]))
    end

    file:write(" {\n\n")

    -- write functions
    if type.functions then
        for j, func in ipairs(type.functions) do
            output_function(file, func)
        end
    end

    -- write end of class
    file:write("}\n\n")
end

local function output_enum(file, enum)
    -- write enum
    file:write("enum abstract " .. enum.name .. " {\n")

    for j, value in ipairs(enum.constants) do
        -- write enum value
        file:write("\tvar " .. capitalize(value.name) .. " = \"" .. value.name .. "\";\n")
    end

    -- write end of enum
    file:write("}\n\n")
end

local function output_module(name, module)

    local mod_name = capitalize(name)

    -- create file for module
    local file = io.open("output/" .. mod_name .. ".hx", "w")

    -- check if file was created
    if file == nil then
        print("Error: Could not create file for module: " .. mod_name)
        os.exit(1)
    end

    -- write autogenerated timestamp
    local timestamp = os.date("%Y-%m-%d %H:%M:%S")
    file:write("// DO NOT EDIT THIS FILE\n")
    file:write("// GENERATED ON " .. timestamp .. "\n\n")

    -- write package name to file
    file:write("package love." .. name .. ";\n\n")

    -- write imports
    file:write("import haxe.extern.Rest;\n")
    file:write("import lua.Table;\n")
    file:write("import lua.UserData;\n\n")

    -- write class
    file:write(("@:native(\"love.%s\")\n"):format(name))
    file:write("extern class " .. capitalize(mod_name) .. " {\n\n")

    -- write functions
    if module.functions then
        for j, func in ipairs(module.functions) do
            output_function(file, func)
        end
    end

    -- write end of class
    file:write("}\n\n")

    -- write multi-return classes
    if module.functions then
        for j, func in ipairs(module.functions) do
            output_multi_return_function(file, func)
        end
    end

    -- write types if types exist
    if module.types then
        for j, type in ipairs(module.types) do
            output_type(file, type)
        end
    end

    -- write enums if enums exist
    if module.enums then
        for j, enum in ipairs(module.enums) do
            output_enum(file, enum)
        end
    end

    -- close file
    file:close()

    print("Compiled module: " .. mod_name)
end

-- print welcome message with api version
print("Compiling 'LOVE API' version: " .. api.version)

-- top level module
output_module("Love", api)

-- print modules from api
for i, module in ipairs(api.modules) do
    output_module(module.name, module)
end